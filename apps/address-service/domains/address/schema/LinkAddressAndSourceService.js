/**
 * Generated by `createservice address.LinkAddressAndSourceService --type mutations`
 */

const { parseAddressesFromString } = require('@open-condo/clients/address-service-client/utils')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema } = require('@open-condo/keystone/schema')

const access = require('@address-service/domains/address/access/LinkAddressAndSourceService')
const { EMPTY_SOURCE } = require('@address-service/domains/address/constants')
const { AddressSource } = require('@address-service/domains/address/utils/serverSchema')
const { mergeAddressAndHelpers } = require('@address-service/domains/common/utils/services/search/searchServiceUtils')

const ERRORS = {
    EMPTY_ADDRESS_SOURCE: {
        query: 'linkAddressAndSource',
        code: BAD_USER_INPUT,
        type: EMPTY_SOURCE,
        message: 'Address source is empty',
    },
}

const LinkAddressAndSourceService = new GQLCustomSchema('LinkAddressAndSourceService', {
    types: [
        {
            access: true,
            type: 'input LinkAddressAndSourceInput { dv: Int!, sender: JSON!, source: String!, tin: String!, address: ID!, withUnitName: Boolean! }',
        },
        {
            access: true,
            type: 'type LinkAddressAndSourceOutput { addressSource: ID!, addressSourceCompounded: ID! }',
        },
    ],

    mutations: [
        {
            access: access.canLinkAddressAndSource,
            schema: 'linkAddressAndSource(data: LinkAddressAndSourceInput!): LinkAddressAndSourceOutput',
            resolver: async (parent, { data }, context) => {
                let { dv, sender, source, tin, address, withUnitName } = data
                if (withUnitName) {
                    source = parseAddressesFromString([source])[0].result.address
                }

                if (!source) {
                    throw new GQLError({
                        ...ERRORS.EMPTY_ADDRESS_SOURCE,
                    }, context)
                }
                
                const compoundedSource = mergeAddressAndHelpers(source, { tin })
                const createAddressSource = (src) => AddressSource.create(
                    context,
                    {
                        dv,
                        sender,
                        source: src,
                        address: { connect: { id: address } },
                    },
                )

                const [addressSource, addressSourceCompounded] = await Promise.all([
                    createAddressSource(source),
                    createAddressSource(compoundedSource),
                ])

                return {
                    addressSource: addressSource.id,
                    addressSourceCompounded: addressSourceCompounded.id,
                }
            },
        },
    ],
})

module.exports = {
    LinkAddressAndSourceService,
}
