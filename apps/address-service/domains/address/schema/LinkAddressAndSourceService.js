/**
 * Generated by `createservice address.LinkAddressAndSourceService --type mutations`
 */

const { parseAddressesFromString } = require('@open-condo/clients/address-service-client/utils')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema, find } = require('@open-condo/keystone/schema')

const access = require('@address-service/domains/address/access/LinkAddressAndSourceService')
const { EMPTY_SOURCE_ERROR, EMPTY_ADDRESS_ERROR, SOURCE_ALREADY_EXISTS_ERROR, INCORRECT_ADDRESS_SOURCE_ERROR, INCORRECT_ADDRESS_ERROR } = require('@address-service/domains/address/constants')
const { AddressSource } = require('@address-service/domains/address/utils/serverSchema')
const { mergeAddressAndHelpers } = require('@address-service/domains/common/utils/services/search/searchServiceUtils')

const ERRORS = {
    EMPTY_SOURCE: {
        query: 'linkAddressAndSource',
        code: BAD_USER_INPUT,
        type: EMPTY_SOURCE_ERROR,
        message: 'Source is empty',
    },
    EMPTY_ADDRESS: {
        query: 'linkAddressAndSource',
        code: BAD_USER_INPUT,
        type: EMPTY_ADDRESS_ERROR,
        message: 'Address is empty',
    },
    INCORRECT_ADDRESS_SOURCE: {
        query: 'linkAddressAndSource',
        code: BAD_USER_INPUT,
        type: INCORRECT_ADDRESS_SOURCE_ERROR,
        message: 'Incorrect address source',
    },
    INCORRECT_ADDRESS: {
        query: 'linkAddressAndSource',
        code: BAD_USER_INPUT,
        type: INCORRECT_ADDRESS_ERROR,
        message: 'Incorrect address',
    },
    SAME_SOURCE: {
        mutation: 'linkAddressAndSource',
        code: BAD_USER_INPUT,
        type: SOURCE_ALREADY_EXISTS_ERROR,
        message: 'This source already exists',
    },
}

const LinkAddressAndSourceService = new GQLCustomSchema('LinkAddressAndSourceService', {
    types: [
        {
            access: true,
            type: 'input LinkAddressAndSourceHelpersInput { tin: String }',
        },
        {
            access: true,
            type: 'input LinkAddressAndSourceInput { dv: Int!, sender: SenderFieldInput!, source: String!, helpers: LinkAddressAndSourceHelpersInput, address: AddressWhereUniqueInput!, parseUnit: Boolean }',
        },
        {
            access: true,
            type: 'type LinkAddressAndSourceOutput { addressSourceId: ID! }',
        },
    ],

    mutations: [
        {
            access: access.canLinkAddressAndSource,
            schema: 'linkAddressAndSource(data: LinkAddressAndSourceInput!): LinkAddressAndSourceOutput',
            resolver: async (parent, { data }, context) => {
                let { dv, sender, source, helpers, address, parseUnit } = data

                if (!source) {
                    throw new GQLError(ERRORS.EMPTY_SOURCE, context)
                }

                if (!address.id) {
                    throw new GQLError(ERRORS.EMPTY_ADDRESS, context)
                }

                if (parseUnit) {
                    source = parseAddressesFromString([source])[0].result.address
                }

                if (!source) {
                    throw new GQLError(ERRORS.INCORRECT_ADDRESS_SOURCE, context)
                }

                if (helpers.tin) {
                    source = mergeAddressAndHelpers(source, { tin: helpers.tin })
                }

                const lowerCasedSource = source.toLowerCase()
                const [existingSource] = await find('AddressSource', {
                    source: lowerCasedSource,
                    deletedAt: null,
                })

                if (existingSource) {
                    throw new GQLError(ERRORS.SAME_SOURCE, context)
                }

                const [existingAddress] = await find('Address', {
                    id: address.id,
                    deletedAt: null,
                })

                if (!existingAddress) {
                    throw new GQLError(ERRORS.INCORRECT_ADDRESS, context)
                }

                const addressSource = await AddressSource.create(
                    context,
                    {
                        dv,
                        sender,
                        source,
                        address: { connect: address },
                    },
                )

                return { addressSourceId: addressSource.id }
            },
        },
    ],
})

module.exports = {
    LinkAddressAndSourceService,
    ERRORS,
}
