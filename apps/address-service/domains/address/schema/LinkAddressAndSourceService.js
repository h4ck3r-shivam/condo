/**
 * Generated by `createservice address.LinkAddressAndSourceService --type mutations`
 */

const { parseAddressesFromString } = require('@open-condo/clients/address-service-client/utils')
const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema } = require('@open-condo/keystone/schema')

const access = require('@address-service/domains/address/access/LinkAddressAndSourceService')
const { EMPTY_SOURCE, EMPTY_ADDRESS, SOURCE_ALREADY_EXISTS_ERROR, INCORRECT_ADDRESS_SOURCE } = require('@address-service/domains/address/constants')
const { AddressSource } = require('@address-service/domains/address/utils/serverSchema')
const { mergeAddressAndHelpers } = require('@address-service/domains/common/utils/services/search/searchServiceUtils')

const ERRORS = {
    EMPTY_SOURCE: {
        query: 'linkAddressAndSource',
        code: BAD_USER_INPUT,
        type: EMPTY_SOURCE,
        message: 'Source is empty',
    },
    EMPTY_ADDRESS: {
        query: 'linkAddressAndSource',
        code: BAD_USER_INPUT,
        type: EMPTY_ADDRESS,
        message: 'Address is empty',
    },
    INCORRECT_ADDRESS_SOURCE: {
        query: 'linkAddressAndSource',
        code: BAD_USER_INPUT,
        type: INCORRECT_ADDRESS_SOURCE,
        message: 'Incorrect address source',
    },
    SAME_SOURCE: {
        mutation: 'createAddressSource',
        code: BAD_USER_INPUT,
        type: SOURCE_ALREADY_EXISTS_ERROR,
        message: 'Source with the same address already exists',
    },
}

const LinkAddressAndSourceService = new GQLCustomSchema('LinkAddressAndSourceService', {
    types: [
        {
            access: true,
            type: 'input LinkAddressAndSourceInput { dv: Int!, sender: JSON!, source: String!, tin: String, address: ID!, parseUnit: Boolean }',
        },
        {
            access: true,
            type: 'type LinkAddressAndSourceOutput { addressSourceId: ID! }',
        },
    ],

    mutations: [
        {
            access: access.canLinkAddressAndSource,
            schema: 'linkAddressAndSource(data: LinkAddressAndSourceInput!): LinkAddressAndSourceOutput',
            resolver: async (parent, { data }, context) => {
                let { dv, sender, source, tin, address, parseUnit } = data

                if (!source) {
                    throw new GQLError({
                        ...ERRORS.EMPTY_SOURCE,
                    }, context)
                }

                if (!address) {
                    throw new GQLError({
                        ...ERRORS.EMPTY_ADDRESS,
                    }, context)
                }

                if (parseUnit) {
                    source = parseAddressesFromString([source])[0].result.address
                }

                if (!source) {
                    throw new GQLError({
                        ...ERRORS.INCORRECT_ADDRESS_SOURCE,
                    }, context)
                }

                if (tin) {
                    source = mergeAddressAndHelpers(source, { tin })
                }
                try {
                    const addressSource = await AddressSource.create(
                        context,
                        {
                            dv,
                            sender,
                            source,
                            address: { connect: { id: address } },
                        },
                    )
                    return {
                        addressSourceId: addressSource.id,
                    }
                } catch (e) {
                    throw new GQLError(ERRORS.SAME_SOURCE, context)
                }
            },
        },
    ],
})

module.exports = {
    LinkAddressAndSourceService,
    ERRORS,
}
