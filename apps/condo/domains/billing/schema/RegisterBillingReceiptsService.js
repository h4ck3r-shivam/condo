/**
 * Generated by `createservice billing.RegisterBillingReceiptsService --type mutations`
 */

const { get } = require('lodash')

const { GQLError } = require('@open-condo/keystone/errors')
const { getLogger } = require('@open-condo/keystone/logging')
const { getRedisClient } = require('@open-condo/keystone/redis')
const { find, GQLCustomSchema } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/billing/access/RegisterBillingReceiptsService')
const {
    RECEIPTS_LIMIT,
    ERRORS,
} = require('@condo/domains/billing/constants/registerBillingReceiptService')
const {
    CategoryResolver,
    RecipientResolver,
    PropertyResolver,
    AccountResolver,
    PeriodResolver,
    ReceiptResolver,
} = require('@condo/domains/billing/schema/resolvers')
const { sortPeriodFunction } = require('@condo/domains/billing/schema/resolvers/utils')
const { BillingReceipt } = require('@condo/domains/billing/utils/serverSchema')
const {
    BillingIntegrationOrganizationContextForRegisterBillingReceiptsService: BillingContextApi,
} = require('@condo/domains/billing/utils/serverSchema')
const { ReceiptInputCache } = require('@condo/domains/billing/utils/serverSchema/receiptInputCache')

const appLogger = getLogger('condo')
const registerReceiptLogger = appLogger.child({ module: 'register-billing-receipts' })

const redisClient = getRedisClient('register-billing-receipts', 'cache')
const getRedisKey = (billingContextId, controlSum) => `register-billing-receipt:${billingContextId}:${controlSum}`

const RegisterBillingReceiptsService = new GQLCustomSchema('RegisterBillingReceiptsService', {
    types: [
        {
            access: true,
            type: `input RegisterBillingReceiptAddressMetaInput {
                globalId: String
                importId: String
                unitName: String
                unitType: String
            }`,
        },
        {
            access: true,
            type: `input RegisterBillingReceiptAccountMetaInput {
                globalId: String 
                importId: String
                fullName: String
                isClosed: Boolean
                ownerType: BillingAccountOwnerTypeType
            }`,
        },
        {
            access: true,
            type: 'input RegisterBillingReceiptInput ' +
                '{ ' +
                    'importId: String ' +

                    'address: String! ' +
                    'addressMeta: RegisterBillingReceiptAddressMetaInput ' +

                    'accountNumber: String! ' +
                    'accountMeta: RegisterBillingReceiptAccountMetaInput ' +

                    'toPay: String! ' +
                    'toPayDetails: BillingReceiptServiceToPayDetailsFieldInput ' +
                    'services: [BillingReceiptServiceFieldInput] ' +

                    'category: BillingCategoryWhereUniqueInput ' +

                    'month: Int! ' +
                    'year: Int! ' +

                    'tin: String! ' +
                    'routingNumber: String! ' +
                    'bankAccount: String! ' +

                    'raw: JSON ' +

                    // [DEPRECATED] Not used fields will be removed
                    'unitName: String ' +
                    'unitType: String ' +
                    'normalizedAddress: String ' +
                    'fullName: String ' +
                    'tinMeta: JSON ' +
                    'routingNumberMeta: JSON' +
                '}',
        },
        {
            access: true,
            type: 'input RegisterBillingReceiptsInput { dv: Int!, sender: SenderFieldInput!, context: BillingIntegrationOrganizationContextWhereUniqueInput, receipts: [RegisterBillingReceiptInput!]! }',
        },
    ],

    mutations: [
        {
            access: access.canRegisterBillingReceipts,
            schema: 'registerBillingReceipts(data: RegisterBillingReceiptsInput!): [BillingReceipt]',
            resolver: async (parent, args, context = {}) => {
                const { data: { context: billingContextInput, receipts: receiptsInput, dv, sender } } = args
                // The flow description:
                // 1. Normalize addresses
                // 2. Collect data for BillingProblems
                // 3. Create BillingRecipients
                // 4. Auto-detect BillingCategory

                // Input guard validations
                if (receiptsInput.length > RECEIPTS_LIMIT) {
                    throw new GQLError(ERRORS.RECEIPTS_LIMIT_HIT, context)
                }
                const { id: billingContextId } = billingContextInput
                const billingContext = await BillingContextApi.getOne(context, { id: billingContextId })
                if (!billingContextId || !billingContext) {
                    throw new GQLError(ERRORS.BILLING_CONTEXT_NOT_FOUND, context)
                }

                // preserve order for response
                // errors are critical and receipt will be skipped, problems can be fixed later
                let receiptIndex = {}
                let errorsIndex = {}
                let unchangedIndex = {}
                const cache = new ReceiptInputCache(redisClient, getRedisKey, billingContextId)

                for (let index = 0; index < receiptsInput.length; index++) {
                    const receiptInput = receiptsInput[index]
                    const cachedImportId = await cache.getReceiptImportId(receiptInput, index)

                    if (cachedImportId) {
                        unchangedIndex[index] = { importId: cachedImportId }
                    } else {
                        receiptIndex[index] = { ...receiptInput, error: null, problems: [] }
                    }
                }

                const debug = []
                const resolvers = [PeriodResolver, RecipientResolver, PropertyResolver, AccountResolver, CategoryResolver, ReceiptResolver]
                let receiptsPeriods = []
                for (const resolver of resolvers) {
                    try {
                        const worker = new resolver({ context, billingContext })
                        await worker.init()
                        const { errorReceipts, receipts } = await worker.processReceipts(receiptIndex)
                        debug.push(...worker.debugMessages)
                        errorsIndex = { ...errorsIndex, ...errorReceipts }
                        receiptIndex = receipts
                        if (!receiptsPeriods.length) {
                            receiptsPeriods = [...new Set(Object.values(receiptIndex).map(({ period }) => period).filter(Boolean))]
                        }
                    } catch (error) {
                        registerReceiptLogger.error({ msg: 'Resolver fail', payload: { error } })
                    }
                }
                registerReceiptLogger.info({
                    msg: 'register-receipts-profiler',
                    debug,
                    context: billingContextInput,
                    receiptsCount: receiptsInput.length,
                })

                for (const index of Object.keys(receiptIndex)) {
                    await cache.setReceiptImportId(null, index)
                }

                const receiptsFindData = {
                    ids: Object.values(receiptIndex).map(({ id }) => id),
                    importIds: Object.values(unchangedIndex).map(({ importId }) => importId),
                }

                let receipts = []
                if (Object.values(receiptsFindData).some(findData => findData.length)) {
                    receipts = await find('BillingReceipt', {
                        OR: [
                            { id_in: receiptsFindData.ids },
                            { importId_in: receiptsFindData.importIds },
                        ],
                    })
                }

                const receiptsIndex = Object.fromEntries(receipts.map(receipt => ([receipt.id, receipt])))
                const importIdToId = Object.fromEntries(receipts.map(receipt => ([receipt.importId, receipt.id])))
                if (receiptsPeriods.length) {
                    const newestPeriodFromReceipts = receiptsPeriods.sort(sortPeriodFunction).pop()
                    const newerReceiptsCount = await BillingReceipt.count(context, {
                        context: billingContextInput,
                        period_gt: newestPeriodFromReceipts,
                    })
                    if (!newerReceiptsCount) {
                        const currentPeriodReceiptsCount = await BillingReceipt.count(context, {
                            context: billingContextInput,
                            period: newestPeriodFromReceipts,
                        })
                        await BillingContextApi.update(context, billingContextId, {
                            dv, sender,
                            lastReport: {
                                period: newestPeriodFromReceipts,
                                finishTime: new Date().toISOString(),
                                totalReceipts: currentPeriodReceiptsCount,
                            },
                        })
                    }
                }
                return Object.values({ ...receiptIndex, ...unchangedIndex, ...errorsIndex }).map(idOrError => {
                    const id = get(idOrError, 'id')
                    const importId = get(idOrError, 'importId')

                    if (id) {
                        return Promise.resolve(receiptsIndex[id])
                    } else if (importId) {
                        return Promise.resolve(receiptsIndex[importIdToId[importId]])
                    } else {
                        return Promise.reject(idOrError)
                    }
                })
            },
        },
    ],
})

module.exports = {
    RegisterBillingReceiptsService,
    errors: ERRORS,
}
