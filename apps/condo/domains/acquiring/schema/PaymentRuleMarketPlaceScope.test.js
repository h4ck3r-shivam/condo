/**
 * Generated by `createschema acquiring.PaymentRuleMarketPlaceScope 'paymentRule:Relationship:PaymentRule:PROTECT;property?:Relationship:Property:PROTECT;squIds?:Json'`
 */

const { makeLoggedInAdminClient, makeClient, UUID_RE, DATETIME_RE, waitFor, expectValuesOfCommonFields,
    expectToThrowValidationFailureError, expectToThrowGQLError
} = require('@open-condo/keystone/test.utils')

const {
    expectToThrowAuthenticationErrorToObj, expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj, expectToThrowAccessDeniedErrorToObjects,
} = require('@open-condo/keystone/test.utils')

const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser } = require('@condo/domains/user/utils/testSchema')

const { PaymentRuleMarketPlaceScope, createTestPaymentRuleMarketPlaceScope, updateTestPaymentRuleMarketPlaceScope } = require('@condo/domains/acquiring/utils/testSchema')
const {createTestOrganization} = require("../../organization/utils/testSchema");
const {addAcquiringIntegrationAndContext, createTestPaymentRule} = require("../utils/testSchema");
const {createTestBankAccount} = require("../../banking/utils/testSchema");
const {createTestProperty} = require("../../property/utils/testSchema");


function expectedFields (client, paymentRuleMarketScope, paymentRule, attrs) {
    return {
        id: paymentRuleMarketScope.id,
        paymentRule: expect.objectContaining({ id: paymentRule.id }),
        property: attrs.property ? expect.objectContaining({ id: attrs.property }) : null,
        skuIds: attrs.skuIds ? attrs.skuIds : null,
        dv: 1,
        sender: attrs.sender,
        v: 1,
        newId: null,
        deletedAt: null,
        createdBy: expect.objectContaining({ id: client.user.id }),
        updatedBy: expect.objectContaining({ id: client.user.id }),
        createdAt: expect.stringMatching(DATETIME_RE),
        updatedAt: expect.stringMatching(DATETIME_RE),
    }
}

describe('PaymentRuleMarketPlaceScope', () => {

    let admin
    let organization
    let acquiringIntegrationContext
    let bankAccount
    let paymentRule
    beforeEach(async () => {
        admin = await makeLoggedInAdminClient();
        [organization] = await createTestOrganization(admin)
        const integrationAndContext = await addAcquiringIntegrationAndContext(admin, organization)
        acquiringIntegrationContext = integrationAndContext.acquiringIntegrationContext;
        [bankAccount] = await createTestBankAccount(admin, organization);
        [paymentRule] = await createTestPaymentRule(admin, acquiringIntegrationContext, bankAccount)
    })

    describe('CRUD tests', () => {
        describe('create', () => {
            test('admin can', async () => {
                const [obj, attrs] = await createTestPaymentRuleMarketPlaceScope(admin, paymentRule, { skuIds: ['1'] })
                expectValuesOfCommonFields(obj, attrs, admin)
                expect(obj.paymentRule).toEqual(expect.objectContaining({ id: paymentRule.id }))
            })

            test('support can', async () => {
                const support = await makeClientWithSupportUser()
                const [obj, attrs] = await createTestPaymentRuleMarketPlaceScope(support, paymentRule, { skuIds: ['1'] })
                expectValuesOfCommonFields(obj, attrs, support)
                expect(obj.paymentRule).toEqual(expect.objectContaining({ id: paymentRule.id }))
            })

            test('user can\'t', async () => {
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObj(async () =>
                    await createTestPaymentRuleMarketPlaceScope(client, paymentRule, { skuIds: ['1'] })
                )
            })

            test('anonymous can\'t', async () => {
                const client = await makeClient()

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestPaymentRuleMarketPlaceScope(client, paymentRule, { skuIds: ['1'] })
                })
            })
        })

        describe('update', () => {
            test('admin can', async () => {
                const [objCreated] = await createTestPaymentRuleMarketPlaceScope(admin, paymentRule, { skuIds: ['1'] })
                const [obj, attrs] = await updateTestPaymentRuleMarketPlaceScope(admin, objCreated.id, { skuIds: ['2'] })

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: admin.user.id }))
                expect(obj.skuIds).toEqual(['2'])
            })

            test('support can', async () => {
                const support = await makeClientWithSupportUser()
                const [objCreated] = await createTestPaymentRuleMarketPlaceScope(support, paymentRule, { skuIds: ['1'] })
                const [obj, attrs] = await updateTestPaymentRuleMarketPlaceScope(support, objCreated.id, { skuIds: ['2'] })

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: support.user.id }))
                expect(obj.skuIds).toEqual(['2'])
            })

            test('user can\'t', async () => {
                const [objCreated] = await createTestPaymentRuleMarketPlaceScope(admin, paymentRule, { skuIds: ['1'] })

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObj(async () =>
                    await updateTestPaymentRuleMarketPlaceScope(client, objCreated.id, { skuIds: ['2'] })
                )
            })

            test('anonymous can\'t', async () => {
                const [objCreated] = await createTestPaymentRuleMarketPlaceScope(admin, paymentRule, { skuIds: ['1'] })

                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestPaymentRuleMarketPlaceScope(client, objCreated.id, { skuIds: ['2'] })
                })
            })
        })

        describe('hard delete', () => {
            test('admin can\'t', async () => {
                const admin = await makeLoggedInAdminClient()
                const [objCreated] = await createTestPaymentRuleMarketPlaceScope(admin, paymentRule, { skuIds: ['1'] })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await PaymentRuleMarketPlaceScope.delete(admin, objCreated.id)
                })
            })

            test('user can\'t', async () => {
                const admin = await makeLoggedInAdminClient()
                const [objCreated] = await createTestPaymentRuleMarketPlaceScope(admin, paymentRule, { skuIds: ['1'] })

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await PaymentRuleMarketPlaceScope.delete(client, objCreated.id)
                })
            })

            test('anonymous can\'t', async () => {
                const admin = await makeLoggedInAdminClient()
                const [objCreated] = await createTestPaymentRuleMarketPlaceScope(admin, paymentRule, { skuIds: ['1'] })

                const client = await makeClient()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await PaymentRuleMarketPlaceScope.delete(client, objCreated.id)
                })
            })
        })

        describe('read', () => {
            test('admin can', async () => {
                const [obj, attrs] = await createTestPaymentRuleMarketPlaceScope(admin, paymentRule, { skuIds: ['1'] })

                const objs = await PaymentRuleMarketPlaceScope.getAll(admin, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([expect.objectContaining(expectedFields(admin, obj, paymentRule, attrs))]))
            })

            test('support can', async () => {
                const support = await makeClientWithSupportUser()
                const [obj, attrs] = await createTestPaymentRuleMarketPlaceScope(support, paymentRule, { skuIds: ['1'] })

                const objs = await PaymentRuleMarketPlaceScope.getAll(support, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([expect.objectContaining(expectedFields(support, obj, paymentRule, attrs))]))
            })

            test('user can\'t', async () => {
                await createTestPaymentRuleMarketPlaceScope(admin, paymentRule, { skuIds: ['1'] })
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObjects(async () =>
                    await PaymentRuleMarketPlaceScope.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })
                )
            })


            test('anonymous can\'t', async () => {
                await createTestPaymentRuleMarketPlaceScope(admin, paymentRule, { skuIds: ['1'] })
                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await PaymentRuleMarketPlaceScope.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })  // TODO(codegen): write 'anonymous: read PaymentRuleMarketPlaceScope' test
                })
            })
        })
    })

    describe('Validation tests', () => {
        test('Should have correct dv field (=== 1)', async () => {
            const [obj] = await createTestPaymentRuleMarketPlaceScope(admin, paymentRule, { skuIds: ['1'] })
            expect(obj).toHaveProperty('dv', 1)
        })

        test('Can\'t create if property and payment rule have different organizations', async () => {
            const [anotherOrganization] = await createTestOrganization(admin)
            const [anotherProperty] = await createTestProperty(admin, anotherOrganization)
            await expectToThrowValidationFailureError(async () =>
                await createTestPaymentRuleMarketPlaceScope(admin, paymentRule, { property: { connect: { id: anotherProperty.id } } }),
                '[paymentRuleMarketScope:property:organization:noMatch] Property must be of same organization, as payment rule'
            )
        })

        describe('Can\'t create if skuIds is not array of non-empty strings', () => {
            const invalidSkuIds = [
                [['']],
                [[null]],
                [[undefined]],
                [[1,2,3]],
            ]
            test.each(invalidSkuIds)(`Throws validation error for skuIds: %p`, async (skuIds) => {
                await expectToThrowGQLError(async () =>
                    await createTestPaymentRuleMarketPlaceScope(admin, paymentRule, { skuIds }),
                    {
                        code: 'BAD_USER_INPUT',
                        type: 'PAYMENT_RULE_MARKETPLACE_SCOPE_INVALID_SKU_IDS',
                        message: '"skuIds" field validation error. JSON was not in the correct format',
                    }
                )
            })
        })
    })

    describe('notifications', () => {
        // TODO(codegen): write notifications tests if you have any sendMessage calls or drop this block!
    })
})
