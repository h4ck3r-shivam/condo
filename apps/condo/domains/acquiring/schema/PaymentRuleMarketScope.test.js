/**
 * Generated by `createschema acquiring.PaymentRuleMarketScope 'paymentRule:Relationship:PaymentRule:PROTECT;property?:Relationship:Property:PROTECT;squIds?:Json'`
 */

const { makeLoggedInAdminClient, makeClient, DATETIME_RE, expectValuesOfCommonFields,
    expectToThrowValidationFailureError, expectToThrowGQLError,
} = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAuthenticationErrorToObj, expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj, expectToThrowAccessDeniedErrorToObjects,
} = require('@open-condo/keystone/test.utils')

const { PaymentRuleMarketScope, createTestPaymentRuleMarketScope, updateTestPaymentRuleMarketScope } = require('@condo/domains/acquiring/utils/testSchema')
const { addAcquiringIntegrationAndContext, createTestPaymentRule } = require('@condo/domains/acquiring/utils/testSchema')
const { createTestBankAccount } = require('@condo/domains/banking/utils/testSchema')
const { createTestOrganization } = require('@condo/domains/organization/utils/testSchema')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser } = require('@condo/domains/user/utils/testSchema')


function expectedFields (client, paymentRuleMarketScope, paymentRule, attrs) {
    return {
        id: paymentRuleMarketScope.id,
        paymentRule: expect.objectContaining({ id: paymentRule.id }),
        property: attrs.property ? expect.objectContaining({ id: attrs.property }) : null,
        skuIds: attrs.skuIds ? attrs.skuIds : null,
        dv: 1,
        sender: attrs.sender,
        v: 1,
        newId: null,
        deletedAt: null,
        createdBy: expect.objectContaining({ id: client.user.id }),
        updatedBy: expect.objectContaining({ id: client.user.id }),
        createdAt: expect.stringMatching(DATETIME_RE),
        updatedAt: expect.stringMatching(DATETIME_RE),
    }
}

describe('PaymentRuleMarketScope', () => {

    let admin
    let organization
    let acquiringIntegrationContext
    let bankAccount
    let paymentRule
    beforeEach(async () => {
        admin = await makeLoggedInAdminClient();
        [organization] = await createTestOrganization(admin)
        const integrationAndContext = await addAcquiringIntegrationAndContext(admin, organization)
        acquiringIntegrationContext = integrationAndContext.acquiringIntegrationContext;
        [bankAccount] = await createTestBankAccount(admin, organization);
        [paymentRule] = await createTestPaymentRule(admin, acquiringIntegrationContext, bankAccount)
    })

    describe('CRUD tests', () => {
        describe('create', () => {
            test('admin can', async () => {
                const [obj, attrs] = await createTestPaymentRuleMarketScope(admin, paymentRule, { skuIds: ['1'] })
                expectValuesOfCommonFields(obj, attrs, admin)
                expect(obj.paymentRule).toEqual(expect.objectContaining({ id: paymentRule.id }))
            })

            test('support can', async () => {
                const support = await makeClientWithSupportUser()
                const [obj, attrs] = await createTestPaymentRuleMarketScope(support, paymentRule, { skuIds: ['1'] })
                expectValuesOfCommonFields(obj, attrs, support)
                expect(obj.paymentRule).toEqual(expect.objectContaining({ id: paymentRule.id }))
            })

            test('user can\'t', async () => {
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObj(async () =>
                    await createTestPaymentRuleMarketScope(client, paymentRule, { skuIds: ['1'] })
                )
            })

            test('anonymous can\'t', async () => {
                const client = await makeClient()

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestPaymentRuleMarketScope(client, paymentRule, { skuIds: ['1'] })
                })
            })
        })

        describe('update', () => {
            test('admin can', async () => {
                const [objCreated] = await createTestPaymentRuleMarketScope(admin, paymentRule, { skuIds: ['1'] })
                const [obj, attrs] = await updateTestPaymentRuleMarketScope(admin, objCreated.id, { skuIds: ['2'] })

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: admin.user.id }))
                expect(obj.skuIds).toEqual(['2'])
            })

            test('support can', async () => {
                const support = await makeClientWithSupportUser()
                const [objCreated] = await createTestPaymentRuleMarketScope(support, paymentRule, { skuIds: ['1'] })
                const [obj, attrs] = await updateTestPaymentRuleMarketScope(support, objCreated.id, { skuIds: ['2'] })

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: support.user.id }))
                expect(obj.skuIds).toEqual(['2'])
            })

            test('user can\'t', async () => {
                const [objCreated] = await createTestPaymentRuleMarketScope(admin, paymentRule, { skuIds: ['1'] })

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObj(async () =>
                    await updateTestPaymentRuleMarketScope(client, objCreated.id, { skuIds: ['2'] })
                )
            })

            test('anonymous can\'t', async () => {
                const [objCreated] = await createTestPaymentRuleMarketScope(admin, paymentRule, { skuIds: ['1'] })

                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestPaymentRuleMarketScope(client, objCreated.id, { skuIds: ['2'] })
                })
            })
        })

        describe('hard delete', () => {
            test('admin can\'t', async () => {
                const admin = await makeLoggedInAdminClient()
                const [objCreated] = await createTestPaymentRuleMarketScope(admin, paymentRule, { skuIds: ['1'] })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await PaymentRuleMarketScope.delete(admin, objCreated.id)
                })
            })

            test('user can\'t', async () => {
                const admin = await makeLoggedInAdminClient()
                const [objCreated] = await createTestPaymentRuleMarketScope(admin, paymentRule, { skuIds: ['1'] })

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await PaymentRuleMarketScope.delete(client, objCreated.id)
                })
            })

            test('anonymous can\'t', async () => {
                const admin = await makeLoggedInAdminClient()
                const [objCreated] = await createTestPaymentRuleMarketScope(admin, paymentRule, { skuIds: ['1'] })

                const client = await makeClient()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await PaymentRuleMarketScope.delete(client, objCreated.id)
                })
            })
        })

        describe('read', () => {
            test('admin can', async () => {
                const [obj, attrs] = await createTestPaymentRuleMarketScope(admin, paymentRule, { skuIds: ['1'] })

                const objs = await PaymentRuleMarketScope.getAll(admin, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([expect.objectContaining(expectedFields(admin, obj, paymentRule, attrs))]))
            })

            test('support can', async () => {
                const support = await makeClientWithSupportUser()
                const [obj, attrs] = await createTestPaymentRuleMarketScope(support, paymentRule, { skuIds: ['1'] })

                const objs = await PaymentRuleMarketScope.getAll(support, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([expect.objectContaining(expectedFields(support, obj, paymentRule, attrs))]))
            })

            test('user can\'t', async () => {
                await createTestPaymentRuleMarketScope(admin, paymentRule, { skuIds: ['1'] })
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObjects(async () =>
                    await PaymentRuleMarketScope.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })
                )
            })


            test('anonymous can\'t', async () => {
                await createTestPaymentRuleMarketScope(admin, paymentRule, { skuIds: ['1'] })
                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await PaymentRuleMarketScope.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })
                })
            })
        })
    })

    describe('Validation tests', () => {
        test('Should have correct dv field (=== 1)', async () => {
            const [obj] = await createTestPaymentRuleMarketScope(admin, paymentRule, { skuIds: ['1'] })
            expect(obj).toHaveProperty('dv', 1)
        })

        test('Can\'t create if property and payment rule have different organizations', async () => {
            const [anotherOrganization] = await createTestOrganization(admin)
            const [anotherProperty] = await createTestProperty(admin, anotherOrganization)
            await expectToThrowValidationFailureError(async () =>
                await createTestPaymentRuleMarketScope(admin, paymentRule, { property: { connect: { id: anotherProperty.id } } }),
            '[paymentRuleMarketScope:property:organization:noMatch] Property must be of same organization, as payment rule'
            )
        })

        describe('Can\'t create if skuIds is not array of non-empty strings', () => {
            const invalidSkuIds = [
                [['']],
                [[null]],
                [[undefined]],
                [[1, 2, 3]],
            ]
            test.each(invalidSkuIds)('Throws validation error for skuIds: %p', async (skuIds) => {
                await expectToThrowGQLError(async () =>
                    await createTestPaymentRuleMarketScope(admin, paymentRule, { skuIds }),
                {
                    code: 'BAD_USER_INPUT',
                    type: 'PAYMENT_RULE_MARKET_SCOPE_INVALID_SKU_IDS',
                    message: '"skuIds" field validation error. JSON was not in the correct format',
                }
                )
            })
        })
    })

})
