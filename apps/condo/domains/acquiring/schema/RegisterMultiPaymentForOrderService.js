/**
 * Generated by `createservice acquiring.RegisterMultiPaymentForOrderService`
 */

const Big = require('big.js')
const { isNil, get } = require('lodash')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { checkDvAndSender } = require('@open-condo/keystone/plugins/dvAndSender')
const { GQLCustomSchema, getById } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/acquiring/access/RegisterMultiPaymentForOrderService')
const {
    ORDERS_ARE_DELETED,
    ORDERS_HAVE_NEGATIVE_TO_PAY_VALUE,
    ACQUIRING_INTEGRATION_DOES_NOT_SUPPORTS_BILLING_INTEGRATION,
    RECEIPT_HAS_DELETED_BILLING_INTEGRATION,
    BILLING_INTEGRATION_ORGANIZATION_CONTEXT_IS_DELETED,
    ACQUIRING_INTEGRATION_IS_DELETED,
    CANNOT_FIND_ALL_ORDERS,
    ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED,
} = require('@condo/domains/acquiring/constants/errors')
const {
    WEB_VIEW_PATH,
    FEE_CALCULATION_PATH,
    DIRECT_PAYMENT_PATH,
    ANONYMOUS_PAYMENT_PATH,
} = require('@condo/domains/acquiring/constants/links')
const { DEFAULT_MULTIPAYMENT_SERVICE_CATEGORY } = require('@condo/domains/acquiring/constants/payment')
const { freezeOrder } = require('@condo/domains/acquiring/utils/freezeOrder')
const { AcquiringIntegration, Payment, MultiPayment } = require('@condo/domains/acquiring/utils/serverSchema')
const { getAcquiringIntegrationContextFormula, FeeDistribution } = require('@condo/domains/acquiring/utils/serverSchema/feeDistribution')
const { DV_VERSION_MISMATCH, WRONG_FORMAT } = require('@condo/domains/common/constants/errors')

/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    DV_VERSION_MISMATCH: {
        mutation: 'registerMultiPaymentForOrder',
        variable: ['data', 'dv'],
        code: BAD_USER_INPUT,
        type: DV_VERSION_MISMATCH,
        message: 'Wrong value for data version number',
    },
    WRONG_SENDER_FORMAT: {
        mutation: 'registerMultiPaymentForOrder',
        variable: ['data', 'sender'],
        code: BAD_USER_INPUT,
        type: WRONG_FORMAT,
        message: 'Invalid format of "sender" field value. {details}',
        correctExample: '{ dv: 1, fingerprint: \'example-fingerprint-alphanumeric-value\'}',
    },
    ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED: {
        mutation: 'registerMultiPaymentForOrder',
        variable: ['data', 'acquiringIntegrationContext', 'id'],
        code: BAD_USER_INPUT,
        type: ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED,
        message: 'Cannot pay via deleted acquiring integration context',
    },
    ACQUIRING_INTEGRATION_IS_DELETED: {
        mutation: 'registerMultiPaymentForOrder',
        variable: ['data', 'acquiringIntegrationContext', 'id'],
        code: BAD_USER_INPUT,
        type: ACQUIRING_INTEGRATION_IS_DELETED,
        message: 'Cannot pay via deleted acquiring integration with id "{id}"',
    },
    CANNOT_FIND_ORDER: {
        mutation: 'registerMultiPaymentForOrder',
        variable: ['data', 'orderObj', 'id'],
        code: BAD_USER_INPUT,
        type: CANNOT_FIND_ALL_ORDERS,
        message: 'Cannot find specified Order with id {missingOrderId}',
    },
    ORDER_IS_DELETED: {
        mutation: 'registerMultiPaymentForOrder',
        variable: ['data', 'orderObj', 'id'],
        code: BAD_USER_INPUT,
        type: ORDERS_ARE_DELETED,
        message: 'Cannot pay for deleted orderObj {id}',
    },
    ORDER_HAS_NEGATIVE_TO_PAY_VALUE: {
        mutation: 'registerMultiPaymentForOrder',
        variable: ['data', 'orderObj', 'id'],
        code: BAD_USER_INPUT,
        type: ORDERS_HAVE_NEGATIVE_TO_PAY_VALUE,
        message: 'Cannot pay for Order {id} with negative "toPay" value',
    },
    BILLING_INTEGRATION_ORGANIZATION_CONTEXT_IS_DELETED: {
        mutation: 'registerMultiPaymentForOrder',
        variable: ['data', 'orderObj', 'id'],
        code: BAD_USER_INPUT,
        type: BILLING_INTEGRATION_ORGANIZATION_CONTEXT_IS_DELETED,
        message: 'BillingIntegrationOrganizationContext is deleted for provided Order',
    },
    ACQUIRING_INTEGRATION_DOES_NOT_SUPPORTS_BILLING_INTEGRATION: {
        mutation: 'registerMultiPaymentForOrder',
        variable: ['data', 'orderObj', 'id'],
        code: BAD_USER_INPUT,
        type: ACQUIRING_INTEGRATION_DOES_NOT_SUPPORTS_BILLING_INTEGRATION,
        message: 'AcquiringIntegration does not support following Order\'s BillingIntegration: {unsupportedBillingIntegration}',
    },
    ORDER_HAS_DELETED_BILLING_INTEGRATION: {
        mutation: 'registerMultiPaymentForOrder',
        variable: ['data', 'orderObj', 'id'],
        code: BAD_USER_INPUT,
        type: RECEIPT_HAS_DELETED_BILLING_INTEGRATION,
        message: 'Order has deleted BillingIntegration',
    },
}

const RegisterMultiPaymentForOrderService = new GQLCustomSchema('RegisterMultiPaymentForOrderService', {
    types: [
        {
            access: true,
            type: 'input RegisterMultiPaymentForOrderInput { dv: Int!, sender: SenderFieldInput!, orderObj: OrderWhereUniqueInput!, acquiringIntegrationContext: AcquiringIntegrationContextWhereUniqueInput! }',
        },
        {
            access: true,
            type: 'type RegisterMultiPaymentForOrderOutput { dv: Int!, multiPaymentId: String!, webViewUrl: String!, feeCalculationUrl: String!, directPaymentUrl: String!, anonymousPaymentUrl: String! }',
        },
    ],
    
    mutations: [
        {
            access: access.canRegisterMultiPaymentForOrder,
            schema: 'registerMultiPaymentForOrder(data: RegisterMultiPaymentForOrderInput!): RegisterMultiPaymentForOrderOutput',
            resolver: async (parent, args, context, info, extra = {}) => {
                // wrap validator function to the current call context
                const { data } = args
                const { sender, order, acquiringIntegrationContext } = data

                // Stage 0. Check if input is valid
                checkDvAndSender(data, ERRORS.DV_VERSION_MISMATCH, ERRORS.WRONG_SENDER_FORMAT, context)

                // Stage 1: get acquiring context & integration
                const acquiringContext = await getById('AcquiringIntegrationContext', acquiringIntegrationContext.id)

                if (acquiringContext.deletedAt) {
                    throw new GQLError(ERRORS.ACQUIRING_INTEGRATION_CONTEXT_IS_DELETED, context)
                }

                const acquiringIntegration = await AcquiringIntegration.getOne(context, {
                    id: acquiringContext.integration,
                })

                if (acquiringIntegration.deletedAt) {
                    throw new GQLError({
                        ...ERRORS.ACQUIRING_INTEGRATION_IS_DELETED,
                        messageInterpolation: { id: acquiringContext.integration },
                    }, context)
                }

                // Stage 2. Check Order
                const orderObj = await getById('Order', order.id)

                if (isNil(orderObj)) {
                    throw new GQLError({
                        ...ERRORS.CANNOT_FIND_ORDER,
                        messageInterpolation: { missingReceiptId: order.id },
                    }, context)
                }

                if (orderObj.deletedAt) {
                    throw new GQLError({
                        ...ERRORS.ORDER_IS_DELETED,
                        messageInterpolation: { id: orderObj.id },
                    }, context)
                }

                // negative to pay value
                if (Big(orderObj.toPay).lte(0)) {
                    throw new GQLError({
                        ...ERRORS.ORDER_HAS_NEGATIVE_TO_PAY_VALUE,
                        messageInterpolation: { id: orderObj.id },
                    }, context)
                }

                const billingContext = await getById('BillingIntegrationOrganizationContext', orderObj.context)
                const billingIntegration = await getById('BillingIntegration', billingContext.integration)

                if (billingContext.deletedAt) {
                    const failedOrders = [{ orderId: orderObj.id, contextId: orderObj.context }]
                    throw new GQLError({
                        ...ERRORS.BILLING_INTEGRATION_ORGANIZATION_CONTEXT_IS_DELETED,
                        data: { failedOrders },
                    }, context)
                }

                const supportedBillingIntegrationsGroup = get(acquiringIntegration, 'supportedBillingIntegrationsGroup')

                if (billingIntegration.group !== supportedBillingIntegrationsGroup) {
                    throw new GQLError({
                        ...ERRORS.ACQUIRING_INTEGRATION_DOES_NOT_SUPPORTS_BILLING_INTEGRATION,
                        messageInterpolation: { unsupportedBillingIntegration: billingContext.integration },
                    }, context)
                }

                if (billingIntegration.deletedAt) {
                    const failedOrders = [{
                        orderId: orderObj.id,
                        integrationId: billingContext.integration,
                    }]
                    throw new GQLError({
                        ...ERRORS.ORDER_HAS_DELETED_BILLING_INTEGRATION,
                        data: { failedOrders },
                    }, context)
                }

                const currencyCode = get(billingIntegration, ['currencyCode'])

                // Stage 3 Generating payments
                const formula = await getAcquiringIntegrationContextFormula(context, acquiringIntegrationContext.id)
                const feeCalculator = new FeeDistribution(formula)
                const frozenOrder = await freezeOrder(orderObj)
                const billingAccountNumber = get(frozenOrder, ['data', 'accountNumber'])

                const {
                    type,
                    explicitFee = '0',
                    implicitFee = '0',
                    fromReceiptAmountFee = '0',
                } = feeCalculator.calculate(orderObj.toPay)
                const explicitFees = type === 'service' ? {
                    explicitServiceCharge: String(explicitFee),
                    explicitFee: '0',
                } : {
                    explicitServiceCharge: '0',
                    explicitFee: String(explicitFee),
                }
                const paymentCommissionFields = {
                    ...explicitFees,
                    implicitFee: String(implicitFee),
                    serviceFee: String(fromReceiptAmountFee),
                }
                const paymentModel = await Payment.create(context, {
                    dv: 1,
                    sender,
                    amount: orderObj.toPay,
                    currencyCode,
                    accountNumber: billingAccountNumber,
                    order: { connect: { id: orderObj.id } },
                    frozenOrder,
                    context: { connect: { id: acquiringContext.id } },
                    organization: { connect: { id: acquiringContext.organization } },
                    recipientBic: orderObj.recipient.bic,
                    recipientBankAccount: orderObj.recipient.bankAccount,
                    ...paymentCommissionFields,
                })
                const payment = { ...paymentModel, serviceFee: paymentCommissionFields.serviceFee }

                const totalAmount = {
                    amountWithoutExplicitFee: Big(payment.amount),
                    explicitFee: Big(payment.explicitFee),
                    explicitServiceCharge: Big(payment.explicitServiceCharge),
                    serviceFee: Big(payment.serviceFee),
                    implicitFee: Big(payment.implicitFee),
                }

                const authedItemId = get(context, 'authedItem.id')
                const multiPayment = await MultiPayment.create(context, {
                    dv: 1,
                    sender,
                    ...Object.fromEntries(Object.entries(totalAmount).map(([key, value]) => ([key, value.toFixed(2)]))),
                    currencyCode,
                    ...isNil(authedItemId) ? {} : { user: { connect: { id: authedItemId } } },
                    integration: { connect: { id: acquiringIntegration.id } },
                    payments: { connect: [{ id: payment.id }] },
                    // TODO(DOMA-1574): add correct category
                    serviceCategory: DEFAULT_MULTIPAYMENT_SERVICE_CATEGORY,
                })
                return {
                    dv: 1,
                    multiPaymentId: multiPayment.id,
                    webViewUrl: `${acquiringIntegration.hostUrl}${WEB_VIEW_PATH.replace('[id]', multiPayment.id)}`,
                    feeCalculationUrl: `${acquiringIntegration.hostUrl}${FEE_CALCULATION_PATH.replace('[id]', multiPayment.id)}`,
                    directPaymentUrl: `${acquiringIntegration.hostUrl}${DIRECT_PAYMENT_PATH.replace('[id]', multiPayment.id)}`,
                    anonymousPaymentUrl: `${acquiringIntegration.hostUrl}${ANONYMOUS_PAYMENT_PATH.replace('[id]', multiPayment.id)}`,
                }
            },
        },
    ],
    
})

module.exports = {
    RegisterMultiPaymentForOrderService,
}
