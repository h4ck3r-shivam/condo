/**
 * Generated by `createschema acquiring.PaymentRuleBillingScope 'paymentRule:Relationship:PaymentRule:PROTECT;property?:Relationship:Property:PROTECT;category?:Relationship:BillingCategory:PROTECT;bankAccountNumber?:Text;serviceId?:Json'`
 */

const { makeLoggedInAdminClient, makeClient, UUID_RE, DATETIME_RE, expectValuesOfCommonFields,
    expectToThrowValidationFailureError, expectToThrowGQLError,
} = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAuthenticationErrorToObj, expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj, expectToThrowAccessDeniedErrorToObjects,
} = require('@open-condo/keystone/test.utils')

const { PaymentRuleBillingScope, createTestPaymentRuleBillingScope, updateTestPaymentRuleBillingScope,
    createTestPaymentRule,
} = require('@condo/domains/acquiring/utils/testSchema')
const { addAcquiringIntegrationAndContext } = require('@condo/domains/acquiring/utils/testSchema')
const { createTestBankAccount } = require('@condo/domains/banking/utils/testSchema')
const { createTestOrganization } = require('@condo/domains/organization/utils/testSchema')
const { createTestProperty } = require('@condo/domains/property/utils/testSchema')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser } = require('@condo/domains/user/utils/testSchema')



function expectedFields (client, paymentRuleBillingScope, paymentRule, attrs) {
    return {
        id: paymentRuleBillingScope.id,
        paymentRule: expect.objectContaining({ id: paymentRule.id }),
        property: attrs.property ? expect.objectContaining({ id: attrs.property }) : null,
        category: attrs.category ? expect.objectContaining({ id: attrs.category }) : null,
        bankAccountNumber: attrs.bankAccountNumber ? attrs.bankAccountNumber : null,
        serviceIds: attrs.serviceIds ? attrs.serviceIds : null,
        dv: 1,
        sender: attrs.sender,
        v: 1,
        newId: null,
        deletedAt: null,
        createdBy: expect.objectContaining({ id: client.user.id }),
        updatedBy: expect.objectContaining({ id: client.user.id }),
        createdAt: expect.stringMatching(DATETIME_RE),
        updatedAt: expect.stringMatching(DATETIME_RE),
    }
}

describe('PaymentRuleBillingScope', () => {

    let admin
    let organization
    let acquiringIntegrationContext
    let bankAccount
    let paymentRule
    beforeEach(async () => {
        admin = await makeLoggedInAdminClient();
        [organization] = await createTestOrganization(admin)
        const integrationAndContext = await addAcquiringIntegrationAndContext(admin, organization)
        acquiringIntegrationContext = integrationAndContext.acquiringIntegrationContext;
        [bankAccount] = await createTestBankAccount(admin, organization);
        [paymentRule] = await createTestPaymentRule(admin, acquiringIntegrationContext, bankAccount)
    })

    describe('CRUD tests', () => {
        describe('create', () => {
            test('admin can', async () => {
                const [obj, attrs] = await createTestPaymentRuleBillingScope(admin, paymentRule, { bankAccountNumber: '000' })
                expectValuesOfCommonFields(obj, attrs, admin)
                expect(obj).toEqual(expect.objectContaining({
                    bankAccountNumber: '000',
                    paymentRule: expect.objectContaining({ id: paymentRule.id }),
                }))
            })

            test('support can', async () => {
                const client = await makeClientWithSupportUser()
                const [obj, attrs] = await createTestPaymentRuleBillingScope(client, paymentRule, { bankAccountNumber: '000' })
                expectValuesOfCommonFields(obj, attrs, client)
                expect(obj).toEqual(expect.objectContaining({
                    bankAccountNumber: '000',
                    paymentRule: expect.objectContaining({ id: paymentRule.id }),
                }))
            })

            test('user can\'t', async () => {
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObj(async () =>
                    await createTestPaymentRuleBillingScope(client, paymentRule, { bankAccountNumber: '000' })
                )
            })

            test('anonymous can\'t', async () => {
                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestPaymentRuleBillingScope(client, paymentRule, { bankAccountNumber: '000' })
                })
            })
        })

        describe('update', () => {
            test('admin can', async () => {
                const [objCreated] = await createTestPaymentRuleBillingScope(admin, paymentRule, { bankAccountNumber: '000' })
                const [obj, attrs] = await updateTestPaymentRuleBillingScope(admin, objCreated.id, { bankAccountNumber: '001' })

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: admin.user.id }))
            })

            test('support can', async () => {
                const support = await makeClientWithSupportUser()
                const [objCreated] = await createTestPaymentRuleBillingScope(support, paymentRule, { bankAccountNumber: '000' })
                const [obj, attrs] = await updateTestPaymentRuleBillingScope(support, objCreated.id, { bankAccountNumber: '001' })

                expect(obj.id).toMatch(UUID_RE)
                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: support.user.id }))
            })

            test('user can\'t', async () => {
                const admin = await makeLoggedInAdminClient()
                const [objCreated] = await createTestPaymentRuleBillingScope(admin, paymentRule, { bankAccountNumber: '000' })

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObj(async () =>
                    await updateTestPaymentRuleBillingScope(client, objCreated.id, { bankAccountNumber: '001' })
                )
            })

            test('anonymous can\'t', async () => {
                const admin = await makeLoggedInAdminClient()
                const [objCreated] = await createTestPaymentRuleBillingScope(admin, paymentRule, { bankAccountNumber: '000' })

                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestPaymentRuleBillingScope(client, objCreated.id, { bankAccountNumber: '001' })  // TODO(codegen): write 'anonymous: update PaymentRuleBillingScope' test
                })
            })
        })

        describe('hard delete', () => {
            test('admin can\'t', async () => {
                const admin = await makeLoggedInAdminClient()
                const [objCreated] = await createTestPaymentRuleBillingScope(admin, paymentRule, { bankAccountNumber: '000' })

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await PaymentRuleBillingScope.delete(admin, objCreated.id)
                })
            })

            test('user can\'t', async () => {
                const admin = await makeLoggedInAdminClient()
                const [objCreated] = await createTestPaymentRuleBillingScope(admin, paymentRule, { bankAccountNumber: '000' })

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await PaymentRuleBillingScope.delete(client, objCreated.id)
                })
            })

            test('anonymous can\'t', async () => {
                const admin = await makeLoggedInAdminClient()
                const [objCreated] = await createTestPaymentRuleBillingScope(admin, paymentRule, { bankAccountNumber: '000' })

                const client = await makeClient()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await PaymentRuleBillingScope.delete(client, objCreated.id)
                })
            })
        })

        describe('read', () => {
            test('admin can', async () => {
                const [obj, attrs] = await createTestPaymentRuleBillingScope(admin, paymentRule, { bankAccountNumber: '000' })

                const objs = await PaymentRuleBillingScope.getAll(admin, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([expect.objectContaining(expectedFields(admin, obj, paymentRule, attrs))]))
            })

            test('support can', async () => {
                const support = await makeClientWithSupportUser()
                const [obj, attrs] = await createTestPaymentRuleBillingScope(support, paymentRule, { bankAccountNumber: '000' })

                const objs = await PaymentRuleBillingScope.getAll(support, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([expect.objectContaining(expectedFields(support, obj, paymentRule, attrs))]))
            })

            test('user can\'t', async () => {
                await createTestPaymentRuleBillingScope(admin, paymentRule, { bankAccountNumber: '000' })

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObjects(async () =>
                    await PaymentRuleBillingScope.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })
                )
            })

            test('anonymous can\'t', async () => {
                await createTestPaymentRuleBillingScope(admin, paymentRule, { bankAccountNumber: '000' })

                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObjects(async () =>
                    await PaymentRuleBillingScope.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })
                )
            })
        })
    })

    describe('Validation tests', () => {
        test('Should have correct dv field (=== 1)', async () => {
            const [obj] = await createTestPaymentRuleBillingScope(admin, paymentRule, { bankAccountNumber: '000' })
            expect(obj).toHaveProperty('dv', 1)
        })

        test('Can\'t create if property and payment rule organizations are different', async () => {
            const [anotherOrganization] = await createTestOrganization(admin)
            const [anotherProperty] = await createTestProperty(admin, anotherOrganization)
            await expectToThrowValidationFailureError(async () =>
                await createTestPaymentRuleBillingScope(admin, paymentRule, { property: { connect: { id: anotherProperty.id } } }),
            'Property must be of same organization, as payment rule'
            )
        })

        test('Can\' create in none if nullable fields are present', async () => {
            await expectToThrowValidationFailureError(
                async () => createTestPaymentRuleBillingScope(admin, paymentRule),
                '[paymentRuleBillingScope:emptyFields] At least one field besides payment rule must be present'
            )
        })

        describe('Can\'t create if serviceIds is not array of non-empty strings', () => {
            const invalidServiceIds = [
                [['']],
                [[null]],
                [[undefined]],
                [[1, 2, 3]],
            ]
            test.each(invalidServiceIds)('Throws validation error for serviceIds: %p', async (serviceIds) => {
                await expectToThrowGQLError(async () =>
                    await createTestPaymentRuleBillingScope(admin, paymentRule, { serviceIds }),
                {
                    code: 'BAD_USER_INPUT',
                    type: 'PAYMENT_RULE_BILLING_SCOPE_INVALID_SERVICE_IDS',
                    message: '"serviceIds" field validation error. JSON was not in the correct format',
                }
                )
            })
        })
    })

    describe('notifications', () => {
        // TODO(codegen): write notifications tests if you have any sendMessage calls or drop this block!
    })
})
