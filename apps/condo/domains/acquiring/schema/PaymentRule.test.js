/**
 * Generated by `createschema acquiring.PaymentRule 'context:Relationship:AcquiringIntegrationContext:PROTECT;explicitFee?:Decimal;explicitServiceCharge?:Decimal;implicitFee?:Decimal;bankAccount?:Relationship:BankAccount:PROTECT;marketPlaceScope?:Relationship:PaymentRuleMarketPlaceScope:PROTECT;billingScope?:Relationship:PaymentRuleBillingScope:PROTECT'`
 */

const { makeLoggedInAdminClient, makeClient, UUID_RE, DATETIME_RE, waitFor, expectValuesOfCommonFields } = require('@open-condo/keystone/test.utils')
const {
    expectToThrowAuthenticationErrorToObj, expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj, expectToThrowAccessDeniedErrorToObjects,
    expectToThrowValidationFailureError,
} = require('@open-condo/keystone/test.utils')

const { PaymentRule, createTestPaymentRule, updateTestPaymentRule, addAcquiringIntegrationAndContext} = require('@condo/domains/acquiring/utils/testSchema')
const { AcquiringTestMixin } = require('@condo/domains/billing/utils/testSchema/mixins/acquiring')
const { TestUtils } = require('@condo/domains/billing/utils/testSchema/testUtils')
const { makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser } = require('@condo/domains/user/utils/testSchema')
const {createTestOrganization} = require("../../organization/utils/testSchema");
const {createTestBankAccount} = require("../../banking/utils/testSchema");


function expectedFields (client, paymentRule, attrs, acquiringIntegrationContext, bankAccount) {
    return {
        id: paymentRule.id,
        context: expect.objectContaining({ id: acquiringIntegrationContext.id }),
        bankAccount: expect.objectContaining({ id: bankAccount.id }),
        dv: 1,
        sender: attrs.sender,
        v: 1,
        newId: null,
        deletedAt: null,
        createdBy: expect.objectContaining({ id: client.user.id }),
        updatedBy: expect.objectContaining({ id: client.user.id }),
        createdAt: expect.stringMatching(DATETIME_RE),
        updatedAt: expect.stringMatching(DATETIME_RE),
    }
}


describe('PaymentRule', () => {
    
    let admin
    let organization
    let acquiringIntegrationContext
    let bankAccount
    beforeEach(async () => {
        admin = await makeLoggedInAdminClient();
        [organization] = await createTestOrganization(admin)
        const integrationAndContext = await addAcquiringIntegrationAndContext(admin, organization)
        acquiringIntegrationContext = integrationAndContext.acquiringIntegrationContext;
        [bankAccount] = await createTestBankAccount(admin, organization)
    })
    
    describe('CRUD tests', () => {
        describe('create', () => {
            test('admin can', async () => {
                const [obj, attrs] = await createTestPaymentRule(admin, acquiringIntegrationContext, bankAccount)
                expectValuesOfCommonFields(obj, attrs, admin)
                expect(obj.context).toEqual(expect.objectContaining({ id: acquiringIntegrationContext.id }))
                expect(obj.bankAccount).toEqual(expect.objectContaining({ id: bankAccount.id }))
            })

            test('support can', async () => {
                const client = await makeClientWithSupportUser()

                const [obj, attrs] = await createTestPaymentRule(client, acquiringIntegrationContext, bankAccount)

                expectValuesOfCommonFields(obj, attrs, client)
                expect(obj.context).toEqual(expect.objectContaining({ id: acquiringIntegrationContext.id }))
                expect(obj.bankAccount).toEqual(expect.objectContaining({ id: bankAccount.id }))
            })

            test('user can\'t', async () => {
                const client = await makeClientWithNewRegisteredAndLoggedInUser()  // TODO(codegen): create USER client!

                await expectToThrowAccessDeniedErrorToObj(async () =>
                    await createTestPaymentRule(client, acquiringIntegrationContext, bankAccount)
                )
            })

            test('anonymous can\'t', async () => {
                const client = await makeClient()

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestPaymentRule(client, acquiringIntegrationContext, bankAccount)
                })
            })
        })

        describe('update', () => {
            test('admin can', async () => {
                const admin = await makeLoggedInAdminClient()
                const [objCreated] = await createTestPaymentRule(admin, acquiringIntegrationContext, bankAccount)

                const [obj, attrs] = await updateTestPaymentRule(admin, objCreated.id)

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: admin.user.id }))
            })

            test('support can', async () => {
                const admin = await makeLoggedInAdminClient()
                const [objCreated] = await createTestPaymentRule(admin, acquiringIntegrationContext, bankAccount)

                const client = await makeClientWithSupportUser()
                const [obj, attrs] = await updateTestPaymentRule(client, objCreated.id)

                expect(obj.id).toMatch(UUID_RE)
                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: client.user.id }))
            })

            test('user can\'t', async () => {
                const [objCreated] = await createTestPaymentRule(admin, acquiringIntegrationContext, bankAccount)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestPaymentRule(client, objCreated.id)  // TODO(codegen): write 'anonymous: update PaymentRule' test
                })
            })

            test('anonymous can\'t', async () => {
                const admin = await makeLoggedInAdminClient()
                const [objCreated] = await createTestPaymentRule(admin, acquiringIntegrationContext, bankAccount)

                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestPaymentRule(client, objCreated.id)  // TODO(codegen): write 'anonymous: update PaymentRule' test
                })
            })
        })

        describe('hard delete', () => {
            test('admin can\'t', async () => {
                const admin = await makeLoggedInAdminClient()
                const [objCreated] = await createTestPaymentRule(admin, acquiringIntegrationContext, bankAccount)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await PaymentRule.delete(admin, objCreated.id)  // TODO(codegen): write 'admin: delete PaymentRule' test
                })
            })

            test('user can\'t', async () => {
                const admin = await makeLoggedInAdminClient()
                const [objCreated] = await createTestPaymentRule(admin, acquiringIntegrationContext, bankAccount)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()  // TODO(codegen): create USER client!
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await PaymentRule.delete(client, objCreated.id)  // TODO(codegen): write 'user: delete PaymentRule' test
                })
            })

            test('anonymous can\'t', async () => {
                const admin = await makeLoggedInAdminClient()
                const [objCreated] = await createTestPaymentRule(admin, acquiringIntegrationContext, bankAccount)

                const client = await makeClient()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await PaymentRule.delete(client, objCreated.id)  // TODO(codegen): write 'anonymous: delete PaymentRule' test
                })
            })
        })

        describe('read', () => {
            test('admin can', async () => {
                const [obj, attrs] = await createTestPaymentRule(admin, acquiringIntegrationContext, bankAccount)

                const objs = await PaymentRule.getAll(admin, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining(expectedFields(admin, obj, attrs, acquiringIntegrationContext, bankAccount)),
                ]))
            })

            test('support can', async () => {
                const support = await makeClientWithSupportUser()
                const [obj, attrs] = await createTestPaymentRule(support, acquiringIntegrationContext, bankAccount)

                const objs = await PaymentRule.getAll(support, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining(expectedFields(support, obj, attrs, acquiringIntegrationContext, bankAccount)),
                ]))
            })

            test('user can\'t', async () => {
                await createTestPaymentRule(admin, acquiringIntegrationContext, bankAccount)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()  // TODO(codegen): create USER client!
                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    await PaymentRule.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })  // TODO(codegen): write 'anonymous: read PaymentRule' test
                })
            })

            test('anonymous can\'t', async () => {
                await createTestPaymentRule(admin, acquiringIntegrationContext, bankAccount)

                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await PaymentRule.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })  // TODO(codegen): write 'anonymous: read PaymentRule' test
                })
            })
        })
    })

    describe('Validation tests', () => {
        test('Should have correct dv field (=== 1)', async () => {
            const [paymentRule] = await createTestPaymentRule(admin, acquiringIntegrationContext, bankAccount)
            expect(paymentRule).toHaveProperty('dv', 1)
        })
        
        test('Bank account and acquiring integration context should match one organization', async () => {
            const [paymentRule] = await createTestPaymentRule(admin, acquiringIntegrationContext, bankAccount)
            expect(paymentRule).toBeDefined()

            const [anotherOrganization] = await createTestOrganization(admin)
            const [anotherBankAccount] = await createTestBankAccount(admin, anotherOrganization)
            await expectToThrowValidationFailureError(
                async () => await createTestPaymentRule(admin, acquiringIntegrationContext, anotherBankAccount),
                '[paymentRule:context:bankAccount:organization:noMatch] Organizations in bank account and acquiring integration context should match'
            )
        })
    })

})
