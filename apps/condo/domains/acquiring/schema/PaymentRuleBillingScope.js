/**
 * Generated by `createschema acquiring.PaymentRuleBillingScope 'paymentRule:Relationship:PaymentRule:PROTECT;property?:Relationship:Property:PROTECT;category?:Relationship:BillingCategory:PROTECT;bankAccountNumber?:Text;serviceId?:Json'`
 */

const { get, pick } = require('lodash')
const Ajv = require('ajv')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema, find, getById} = require('@open-condo/keystone/schema')

const access = require('@condo/domains/acquiring/access/PaymentRuleBillingScope')
const { PAYMENT_RULE_BILLING_SCOPE_INVALID_SERVICE_IDS, PAYMENT_RULE_BILLING_SCOPE_PROPERTY_AND_PAYMENT_RULE_ORGANIZATIONS_DOES_NOT_MATCH, PAYMENT_RULE_BILLING_SCOPE_MISSING_ALL_FIELDS } = require('@condo/domains/acquiring/constants/errors')
const { getGQLErrorValidator } = require('@condo/domains/common/schema/json.utils')


const ajv = new Ajv()

const ERRORS = {
    INVALID_SERVICE_IDS: {
        code: BAD_USER_INPUT,
        type: PAYMENT_RULE_BILLING_SCOPE_INVALID_SERVICE_IDS,
        message: 'Service ids must be array of not empty strings',
        messageForUser: 'api.acquiring.paymentRuleBillingScope.INVALID_SERVICE_IDS',
    },
}


const validateServiceIdsSchema = getGQLErrorValidator(ajv.compile({
    type: 'array',
    items: {
        type: 'string',
        minLength: 1,
    },
}), PAYMENT_RULE_BILLING_SCOPE_INVALID_SERVICE_IDS)


const PaymentRuleBillingScope = new GQLListSchema('PaymentRuleBillingScope', {
    schemaDoc: 'Conditions to match paymentRule with billing receipts',
    fields: {

        paymentRule: {
            schemaDoc: 'Payment rule to apply if billing receipt matches the scope',
            type: 'Relationship',
            ref: 'PaymentRule',
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.PROTECT' },
        },

        property: {
            schemaDoc: 'Address restrictions',
            type: 'Relationship',
            ref: 'Property',
            isRequired: false,
            kmigratorOptions: { null: true, on_delete: 'models.PROTECT' },
            hooks: {
                validateInput: async ({ resolvedData, fieldPath, addFieldValidationError }) => {
                    const propertyId = get(resolvedData, fieldPath)
                    if (!propertyId) {
                        return
                    }

                    const paymentRuleId = get(resolvedData, 'paymentRule')
                    const property = await getById('Property', propertyId)
                    const paymentRule = await getById('PaymentRule', paymentRuleId)
                    if (paymentRule.organization !== property.organization) {
                        return addFieldValidationError(PAYMENT_RULE_BILLING_SCOPE_PROPERTY_AND_PAYMENT_RULE_ORGANIZATIONS_DOES_NOT_MATCH)
                    }
                },
            },
        },

        category: {
            // TODO(codegen): write doc for PaymentRuleBillingScope.category field!
            schemaDoc: 'Determinate if payment rule is working on the specific billing category',
            type: 'Relationship',
            ref: 'BillingCategory',
            kmigratorOptions: { null: true, on_delete: 'models.PROTECT' },
            isRequired: false,
        },

        bankAccountNumber: {
            schemaDoc: 'Defines that the payment rule works only for the specific bank account from the billing receipt',
            type: 'Text',
            isRequired: false,
        },

        serviceIds: {
            schemaDoc: 'Additional payment split according to the services in the billing receipt',
            type: 'Json',
            isRequired: false,
            hooks: {
                validateInput: ({ resolvedData, fieldPath, context }) => {
                    const serviceIds = get(resolvedData, fieldPath)
                    if (!serviceIds) {
                        return
                    }
                    validateServiceIdsSchema({ resolvedData, fieldPath, context })
                },
            },
        },

    },
    hooks: {
        validateInput: async ({ operation, resolvedData, addValidationError }) => {
            const notRequiredFields = Object.keys(pick(resolvedData, ['property', 'category', 'bankAccountNumber', 'serviceIds']))
            const notEmptyNotRequiredFields = notRequiredFields.filter(field => !!resolvedData[field])

            if (!notEmptyNotRequiredFields.length) {
                return addValidationError(PAYMENT_RULE_BILLING_SCOPE_MISSING_ALL_FIELDS)
            }

        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadPaymentRuleBillingScopes,
        create: access.canManagePaymentRuleBillingScopes,
        update: access.canManagePaymentRuleBillingScopes,
        delete: false,
        auth: true,
    },
})

module.exports = {
    PaymentRuleBillingScope,
}
