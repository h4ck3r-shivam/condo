/**
 * Generated by `createschema user.AccessToken 'token:Uuid'`
 */

const cookieSignature = require('cookie-signature')
const { Cookie } = require('express-session')
const get = require('lodash/get')
const { v4: uuid } = require('uuid')

const conf = require('@open-condo/config')
const { userIsAdmin } = require('@open-condo/keystone/access')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema } = require('@open-condo/keystone/schema')

const access = require('@condo/domains/miniapp/access/B2BAccessToken')
const { SERVICE_USER_FIELD } = require('@condo/domains/miniapp/schema/fields/accessRight')

const HTTPS_REGEXP = /^https:/

const COOKIE_OPTIONS = {
    sameSite: HTTPS_REGEXP.test(conf.SERVER_URL) && conf.NODE_ENV === 'production' ? 'None' : 'Lax',
    secure: HTTPS_REGEXP.test(conf.SERVER_URL) && conf.NODE_ENV === 'production',
    maxAge: 1000 * (Math.pow(2, 31) - 1), // ~ 68 years in milliseconds
}

function makeCookie () {
    return new Cookie(COOKIE_OPTIONS).toJSON()
}

function setSession (sessionStore, item, data) {
    const userId = get(item, 'user.id', item.user)
    sessionStore.set(item.token, {
        cookie: makeCookie(),
        keystoneListKey: 'User',
        keystoneItemId: userId,
        extra: data,
    })
}

function destroySession (sessionStore, item) {
    sessionStore.destroy(item.token)
}

const B2BAccessToken = new GQLListSchema('B2BAccessToken', {
    schemaDoc: 'Permanent access tokens for users to constraint scope',
    fields: {

        token: {
            schemaDoc: 'Actual token',
            type: 'Uuid',
            defaultValue: () => uuid(),
            isRequired: true,
            access: {
                read: userIsAdmin,
                create: userIsAdmin,
                update: userIsAdmin,
            },
        },

        signedToken: {
            schemaDoc: 'Pass this in header Authorization: \'Bearer <signedToken>\'',
            type: 'Virtual',
            graphQLReturnType: 'String',
            resolver: (item) => {
                return cookieSignature.sign(item.token, conf.COOKIE_SECRET)
            },
        },

        user: {
            ...SERVICE_USER_FIELD,
        },

        organization: {
            schemaDoc: 'Allowed organization for accesses',
            type: 'Relationship',
            ref: 'Organization',
            many: false,
            isRequired: true,
            knexOptions: { isNotNullable: true }, // Required relationship only!
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
        },

    },
    hooks: {
        afterChange: ({ context, operation, existingItem, updatedItem }) => {
            const tokenUpdated = operation === 'update' && (updatedItem['token'] !== existingItem['token'])
            const softDeleted = operation === 'update' && !existingItem['deletedAt'] && updatedItem['deletedAt']

            if (tokenUpdated || softDeleted) {
                destroySession(context.req.sessionStore, existingItem)
            }

            if (!softDeleted) {
                console.error('updatedItem', updatedItem)
                setSession(context.req.sessionStore, updatedItem, {
                    allowedOrganizations: [get(updatedItem, 'organization')],
                })
            }
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadB2BAccessTokens,
        create: access.canManageB2BAccessTokens,
        update: access.canManageB2BAccessTokens,
        delete: false,
        auth: true,
    },
})

module.exports = {
    B2BAccessToken,
}
