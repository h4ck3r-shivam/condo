/**
 * Generated by `createschema user.AccessToken 'token:Uuid'`
 */

const { faker } = require('@faker-js/faker')
const { gql } = require('graphql-tag')
const { map } = require('lodash')
const { v4: uuidv4 } = require('uuid')

const { getRedisClient } = require('@open-condo/keystone/redis')
const {
    makeLoggedInAdminClient, makeClient, UUID_RE, expectValuesOfCommonFields,
    expectToThrowAccessDeniedError, expectToThrowValidationFailureError,
    expectToThrowAuthenticationErrorToObj, expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj, makeLoggedInClient, expectToThrowAccessDeniedErrorToObjects,
} = require('@open-condo/keystone/test.utils')

const {
    makeClientWithIntegrationAccess,
    createTestBillingIntegrationAccessRight,
    createTestBillingIntegrationOrganizationContext,
    updateTestBillingIntegrationOrganizationContext, createTestBillingIntegration,
} = require('@condo/domains/billing/utils/testSchema')
const { registerBillingReceiptsByTestClient } = require('@condo/domains/billing/utils/testSchema')
const { TestUtils, BillingTestMixin } = require('@condo/domains/billing/utils/testSchema/testUtils')
const { UUID_REGEXP } = require('@condo/domains/common/constants/regexps')
const {
    createTestReadingData,
    registerMetersReadingsByTestClient,
    Meter,
    MeterReading,
} = require('@condo/domains/meter/utils/testSchema')
const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/miniapp/constants')
const { B2BAccessToken, B2BAccessTokenAdmin, createTestB2BAccessToken, updateTestB2BAccessToken } = require('@condo/domains/miniapp/utils/testSchema')
const {
    createTestB2BApp,
    createTestB2BAppContext,
    createTestB2BAppAccessRightSet,
    createTestB2BAppAccessRight,
} = require('@condo/domains/miniapp/utils/testSchema')
const { createTestOrganization } = require('@condo/domains/organization/utils/testSchema')
const { Organization } = require('@condo/domains/organization/utils/testSchema')
const { registerNewOrganization } = require('@condo/domains/organization/utils/testSchema/Organization')
const { createTestPropertyWithMap } = require('@condo/domains/property/utils/testSchema')
const {
    makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser, makeClientWithServiceUser,
} = require('@condo/domains/user/utils/testSchema')



describe('B2BAccessToken', () => {
    const redisClient = getRedisClient()
    let admin
    let serviceUserClient
    let organization
    let billingIntegration
    let billingContext
    beforeEach(async () => {
        admin = await makeLoggedInAdminClient()
        serviceUserClient = await makeClientWithIntegrationAccess()

        ;[organization] = await registerNewOrganization(admin)
        ;[billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, serviceUserClient.integration)
        ;[billingContext] = await updateTestBillingIntegrationOrganizationContext(admin, billingContext.id, { status: CONTEXT_FINISHED_STATUS })
        billingIntegration = serviceUserClient.integration
    })

    async function expectDefinedSessionWith (token, userId, allowedOrganizations) {
        const session = JSON.parse(await redisClient.get(`sess:${token}`))
        expect(session).toBeDefined()
        expect(session).toHaveProperty('cookie')
        expect(session).toHaveProperty('keystoneListKey', 'User')
        expect(session).toHaveProperty('keystoneItemId', userId)
        expect(session).toHaveProperty('extra')
        expect(session.extra).toEqual({ allowedOrganizations })
    }

    describe('CRUD tests', () => {
        describe('create', () => {
            test('admin can', async () => {
                const [obj, attrs] = await createTestB2BAccessToken(admin, serviceUserClient.user, organization)
                expectValuesOfCommonFields(obj, attrs, admin)
            })

            test('support can\'t', async () => {
                const support = await makeClientWithSupportUser()

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestB2BAccessToken(support, serviceUserClient.user, organization)
                })
            })

            test('user can\'t', async () => {
                const client = await makeClientWithNewRegisteredAndLoggedInUser()

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await createTestB2BAccessToken(client, serviceUserClient.user, organization)
                })
            })

            test('anonymous can\'t', async () => {
                const client = await makeClient()

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestB2BAccessToken(client, serviceUserClient.user, organization)
                })
            })
        })

        describe('update', () => {
            test('admin can', async () => {
                const [objCreated] = await createTestB2BAccessToken(admin, serviceUserClient.user, organization)

                const [obj, attrs] = await updateTestB2BAccessToken(admin, objCreated.id)

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: admin.user.id }))
            })

            test('support can\'t', async () => {
                const [objCreated] = await createTestB2BAccessToken(admin, serviceUserClient.user, organization)

                const client = await makeClientWithSupportUser()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestB2BAccessToken(client, objCreated.id)
                })
            })

            test('user can\'t', async () => {
                const [objCreated] = await createTestB2BAccessToken(admin, serviceUserClient.user, organization)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestB2BAccessToken(client, objCreated.id)
                })
            })

            test('anonymous can\'t', async () => {
                const [objCreated] = await createTestB2BAccessToken(admin, serviceUserClient.user, organization)

                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestB2BAccessToken(client, objCreated.id)
                })
            })
        })

        describe('hard delete', () => {
            test('admin can\'t', async () => {
                const [objCreated] = await createTestB2BAccessToken(admin, serviceUserClient.user, organization)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAccessToken.delete(admin, objCreated.id)
                })
            })

            test('user can\'t', async () => {
                const [objCreated] = await createTestB2BAccessToken(admin, serviceUserClient.user, organization)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAccessToken.delete(client, objCreated.id)
                })
            })

            test('anonymous can\'t', async () => {
                const [objCreated] = await createTestB2BAccessToken(admin, serviceUserClient.user, organization)

                const client = await makeClient()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await B2BAccessToken.delete(client, objCreated.id)
                })
            })
        })

        describe('read', () => {
            test('admin can', async () => {
                const [obj] = await createTestB2BAccessToken(admin, serviceUserClient.user, organization)

                const objs = await B2BAccessToken.getAll(admin, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: obj.id,
                    }),
                ]))
            })

            test('support can\'t', async () => {
                await createTestB2BAccessToken(admin, serviceUserClient.user, organization)
                const client = await makeClientWithSupportUser()
                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    await B2BAccessToken.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })
                })
            })

            test('user can\'t', async () => {
                await createTestB2BAccessToken(admin, serviceUserClient.user, organization)
                const client = await makeLoggedInClient()
                await expectToThrowAccessDeniedErrorToObjects(async () => {
                    await B2BAccessToken.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })
                })
            })

            test('anonymous can\'t', async () => {
                await createTestB2BAccessToken(admin, serviceUserClient.user, organization)
                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await B2BAccessToken.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })
                })
            })
        })
    })

    describe('Validations', () => {
        test('Should have correct dv field (=== 1)', async () => {
            const [token] = await createTestB2BAccessToken(admin, serviceUserClient.user, organization)
            expect(token).toHaveProperty('dv', 1)
        })
        
        describe('Fields', () => {
            describe('token', () => {
                describe('read', () => {
                    test('admin can ', async () => {
                        const [token] = await createTestB2BAccessToken(admin, serviceUserClient.user, organization)
                        const foundToken = await B2BAccessTokenAdmin.getOne(admin, { id: token.id } )
                        expect(foundToken.token).toMatch(UUID_RE)
                    })

                    test('support can\'t', async () => {
                        const support = await makeClientWithSupportUser()
                        const [token] = await createTestB2BAccessToken(admin, serviceUserClient.user, organization)
                        await expectToThrowAccessDeniedError(async () => {
                            await B2BAccessTokenAdmin.getOne(support, { id: token.id })
                        }, ['objs'])
                    })

                    test('user can\'t', async () => {
                        const client = await makeClientWithNewRegisteredAndLoggedInUser()
                        const [token] = await createTestB2BAccessToken(admin, serviceUserClient.user, organization)
                        await expectToThrowAccessDeniedError(async () => {
                            await B2BAccessTokenAdmin.getOne(client, { id: token.id })
                        }, ['objs'])
                    })

                    test('anonymous can\'t', async () => {
                        await createTestB2BAccessToken(admin, serviceUserClient.user, organization)
                        const client = await makeClient()
                        await expectToThrowAuthenticationErrorToObjects(async () => {
                            await B2BAccessTokenAdmin.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })
                        })
                    })
                })
                
                describe('create', () => {
                    test('defaults to random uuid', async () => {
                        const [obj] = await createTestB2BAccessToken(admin, serviceUserClient.user, organization)
                        const token = await B2BAccessTokenAdmin.getOne(admin, { id: obj.id })
                        expect(token.token).toMatch(UUID_RE)
                    })
                    
                    test('can be set to uuid explicitly', async () => {
                        const uuid = uuidv4()
                        const [obj] = await createTestB2BAccessToken(admin, serviceUserClient.user, organization, { token: uuid })
                        const token = await B2BAccessTokenAdmin.getOne(admin, { id: obj.id })
                        expect(token.token).toEqual(uuid)
                    })
                })
            })
        
            describe('signedToken', () => {
                test('depends on token value', async () => {
                    let [obj] = await createTestB2BAccessToken(admin, serviceUserClient.user, organization)
                    const token = await B2BAccessTokenAdmin.getOne(admin, { id: obj.id })
                    expect(token.token).toMatch(UUID_RE)

                    await updateTestB2BAccessToken(admin, obj.id, { token: uuidv4() })
                    const updatedToken = await B2BAccessTokenAdmin.getOne(admin, { id: obj.id })
                    expect(token.token).not.toEqual(updatedToken.token)
                    expect(token.signedToken).not.toEqual(updatedToken.signedToken)
                })
            })

            describe('user', () => {
                test('should be service user', async () => {
                    const client = await makeClientWithNewRegisteredAndLoggedInUser()
                    await expectToThrowValidationFailureError(async () => {
                        await createTestB2BAccessToken(admin, client.user, organization)
                    }, '[user] No user specified or it has non-service type')
                })
            })
        })
    })

    describe('Real life cases', () => {

        describe('Common', () => {
            test('signed token allows to send requests with connected user accesses', async () => {
                const anonymous = await makeClient()
                const [obj] = await createTestB2BAccessToken(admin, serviceUserClient.user, organization)
                anonymous.setHeaders({ 'Authorization': `Bearer ${obj.signedToken}` })
                const [organizations] = await Organization.getAll(anonymous, {})
                expect(organizations).toBeDefined()

                const res = await anonymous.query(gql`
                    query {
                        obj: authenticatedUser {
                            id
                            type
                        }
                    }
                `)
                expect(res.errors).not.toBeDefined()
                expect(res.data.obj).toEqual(expect.objectContaining({
                    id: serviceUserClient.user.id,
                    type: 'service',
                }))
            })

            test('can not logout', async () => {
                const anonymous = await makeClient()
                const [obj] = await createTestB2BAccessToken(admin, serviceUserClient.user, organization)
                anonymous.setHeaders({ 'Authorization': `Bearer ${obj.signedToken}` })
                await Organization.getAll(anonymous, {})

                const { errors, data } = await anonymous.mutate(gql`
                    mutation unauthenticateUser {
                        obj: unauthenticateUser {
                            success
                        }
                    }
                `)
                expect(data.obj).toBeNull()
                expect(errors).toEqual([
                    expect.objectContaining({
                        message: 'you can not unauth with access token',
                        name: 'GQLError',
                    }),
                ])

                const [anotherOrganizations] = await Organization.getAll(anonymous, {})
                expect(anotherOrganizations).toBeDefined()
            })

            test('does not set keystone.sid cookie', async () => {
                const anonymous = await makeClient()
                const [obj] = await createTestB2BAccessToken(admin, serviceUserClient.user, organization)
                anonymous.setHeaders({ 'Authorization': `Bearer ${obj.signedToken}` })
                const [organizations] = await Organization.getAll(anonymous, {})
                expect(organizations).toBeDefined()
                const parseCookies = (cookiesStr) => cookiesStr ? Object.fromEntries(cookiesStr.split(';').map(keyv => keyv.split('='))) : null
                const keystoneSidCookieName = 'keystone.sid'
                const defaultClientCookie = parseCookies(serviceUserClient.getCookie())[keystoneSidCookieName]
                const anonymousCookie = parseCookies(anonymous.getCookie())[keystoneSidCookieName]

                console.error(serviceUserClient.getCookie())
                console.error(anonymous.getCookie())

                expect(defaultClientCookie).toBeDefined()
                expect(anonymousCookie).not.toBeDefined()
            })
        })

        describe('signed token scopes accesses by allowed organizations', () => {
            
            test('Organizations', async () => {
                const organizationsGenerationCount = 10
                const [integration] = await createTestBillingIntegration(admin)
                const serviceUserClient = await makeClientWithServiceUser()
                await createTestBillingIntegrationAccessRight(admin, integration, serviceUserClient.user)
                const createdOrganizations = []
                for (let i = 0; i < organizationsGenerationCount; i++) {
                    const [organization] = await createTestOrganization(admin)
                    createdOrganizations.push(organization)
                    let [context] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)
                ;[context] = await updateTestBillingIntegrationOrganizationContext(admin, context.id, { status: CONTEXT_FINISHED_STATUS })
                }

                const organizationsByService = await Organization.getAll(serviceUserClient, {})
                expect(organizationsByService).toHaveLength(organizationsGenerationCount)

                const organizationForToken = faker.helpers.arrayElement(createdOrganizations)
                const [obj] = await createTestB2BAccessToken(admin, serviceUserClient.user, organizationForToken)
                const anonymous = await makeClient()
                anonymous.setHeaders({ 'Authorization': `Bearer ${obj.signedToken}` })
                const organizationsByToken = await Organization.getAll(anonymous, {})
                expect(organizationsByToken).toHaveLength(1)
                expect(organizationsByToken[0]).toHaveProperty('id', organizationForToken.id)
            })
        })

        describe('Billing', () => {

            describe('"registerBillingReceipts"', () => {

                test('can execute with own billing context id', async () => {
                    const utils = new TestUtils([BillingTestMixin])
                    await utils.init()
                    const receipt1 = utils.createJSONReceipt()
                    const receipt2 = utils.createJSONReceipt({
                        ...receipt1,
                        importId: null,
                        address: utils.createAddressWithUnit(),
                        accountNumber: utils.randomNumber(10).toString(),
                    })
                    const [token] = await createTestB2BAccessToken(admin, utils.clients.service.user, utils.organization)
                    const anonymous = await makeClient()
                    anonymous.setHeaders({ 'Authorization': `Bearer ${token.signedToken}` })
                    const [createdReceipts] = await registerBillingReceiptsByTestClient(anonymous, {
                        context: { id: utils.billingContext.id },
                        receipts: [receipt1, receipt2],
                    })
                    console.error(createdReceipts)
                    expect(createdReceipts[0].id).not.toEqual(createdReceipts[1].id)
                })

                test('can\'t execute with another billing context id', async () => {
                    const utils = new TestUtils([BillingTestMixin])
                    const anotherUtils = new TestUtils([BillingTestMixin])
                    await utils.init()
                    await anotherUtils.init()
                    const receipt1 = utils.createJSONReceipt()
                    const receipt2 = utils.createJSONReceipt({
                        ...receipt1,
                        importId: null,
                        address: utils.createAddressWithUnit(),
                        accountNumber: utils.randomNumber(10).toString(),
                    })
                    const [token] = await createTestB2BAccessToken(admin, utils.clients.service.user, utils.organization)
                    const anonymous = await makeClient()
                    anonymous.setHeaders({ 'Authorization': `Bearer ${token.signedToken}` })

                    await expectToThrowAccessDeniedError(async () => {
                        await registerBillingReceiptsByTestClient(anonymous, {
                            context: { id: anotherUtils.billingContext.id },
                            receipts: [receipt1, receipt2],
                        })
                    }, ['result'])
                })

            })

        })

        describe('Meter', () => {
            describe('"registerMetersReadings"', () => {
                
                test('can execute with own organization', async () => {
                    const [organization] = await createTestOrganization(admin)
                    const [property] = await createTestPropertyWithMap(admin, organization)
                    const readings = [createTestReadingData(property)]
                    const serviceUser = await makeClientWithServiceUser()

                    const [app] = await createTestB2BApp(admin)
                    await createTestB2BAppContext(admin, app, organization, { status: 'Finished' })
                    const [accessRightSet] = await createTestB2BAppAccessRightSet(admin, app, {
                        canExecuteRegisterMetersReadings: true,
                        canReadMeters: true,
                        canReadMeterReadings: true,
                        canReadOrganizations: true,
                        canReadProperties: true,
                    })
                    await createTestB2BAppAccessRight(admin, serviceUser.user, app, accessRightSet)

                    const [token] = await createTestB2BAccessToken(admin, serviceUser.user, organization)
                    const anonymous = await makeClient()
                    anonymous.setHeaders({ 'Authorization': `Bearer ${token.signedToken}` })
                    const [data] = await registerMetersReadingsByTestClient(anonymous, organization, readings)

                    expect(data).toEqual([expect.objectContaining({
                        id: expect.stringMatching(UUID_REGEXP),
                        meter: expect.objectContaining({
                            id: expect.stringMatching(UUID_REGEXP),
                            property: expect.objectContaining({
                                id: property.id,
                                address: property.address,
                                addressKey: property.addressKey,
                            }),
                            unitType: readings[0].addressInfo.unitType,
                            unitName: readings[0].addressInfo.unitName,
                            accountNumber: readings[0].accountNumber,
                            number: readings[0].meterNumber,
                        }),
                    })])

                    const meters = await Meter.getAll(anonymous, {
                        organization: { id: organization.id },
                        property: { id: property.id },
                    })
                    expect(meters).toHaveLength(1)
                    expect(meters[0].number).toBe(readings[0].meterNumber)

                    const metersReadings = await MeterReading.getAll(anonymous, { meter: { id_in: map(meters, 'id') } })
                    expect(metersReadings).toHaveLength(1)
                })

                test('can\'t execute with another organization', async () => {
                    const [organization] = await createTestOrganization(admin)
                    const [anotherOrganization] = await createTestOrganization(admin)
                    const [property] = await createTestPropertyWithMap(admin, organization)
                    const readings = [createTestReadingData(property)]
                    const serviceUser = await makeClientWithServiceUser()

                    const [app] = await createTestB2BApp(admin)
                    await createTestB2BAppContext(admin, app, organization, { status: 'Finished' })
                    await createTestB2BAppContext(admin, app, anotherOrganization, { status: 'Finished' })
                    const [accessRightSet] = await createTestB2BAppAccessRightSet(admin, app, {
                        canExecuteRegisterMetersReadings: true,
                        canReadMeters: true,
                        canReadMeterReadings: true,
                        canReadOrganizations: true,
                        canReadProperties: true,
                    })
                    await createTestB2BAppAccessRight(admin, serviceUser.user, app, accessRightSet)

                    const [token] = await createTestB2BAccessToken(admin, serviceUser.user, organization)
                    const anonymous = await makeClient()
                    anonymous.setHeaders({ 'Authorization': `Bearer ${token.signedToken}` })

                    await expectToThrowAccessDeniedError(async () => {
                        await registerMetersReadingsByTestClient(anonymous, anotherOrganization, readings)
                    }, ['result'])
                })
                
            })
        })
        
    })
    
    describe('Hooks', () => {
        test('sets session in redis after it\'s creation', async () => {
            const [obj] = await createTestB2BAccessToken(admin, serviceUserClient.user, organization)
            const fullToken = await B2BAccessTokenAdmin.getOne(admin, { id: obj.id })
            await expectDefinedSessionWith(fullToken.token, serviceUserClient.user.id, [organization.id])
        })

        test('on soft delete removes previous session', async () => {
            const [obj] = await createTestB2BAccessToken(admin, serviceUserClient.user, organization)
            const fullToken = await B2BAccessTokenAdmin.getOne(admin, { id: obj.id })
            await expectDefinedSessionWith(fullToken.token, serviceUserClient.user.id, [organization.id])

            await updateTestB2BAccessToken(admin, obj.id, { deletedAt: new Date().toISOString() })
            const session = await redisClient.get(`sess:${fullToken.token}`)
            expect(session).toBeNull()
        })

        test('on token field update removes previous session and adds new one', async () => {
            const [obj] = await createTestB2BAccessToken(admin, serviceUserClient.user, organization)
            const fullToken = await B2BAccessTokenAdmin.getOne(admin, { id: obj.id })
            await expectDefinedSessionWith(fullToken.token, serviceUserClient.user.id, [organization.id])

            const newToken = uuidv4()
            await updateTestB2BAccessToken(admin, obj.id, { token: newToken })
            const session = await redisClient.get(`sess:${fullToken.token}`)
            expect(session).toBeNull()
            await expectDefinedSessionWith(newToken, serviceUserClient.user.id, [organization.id])
        })

        test('updates session value on organization field change', async () => {
            const [obj] = await createTestB2BAccessToken(admin, serviceUserClient.user, organization)
            const fullToken = await B2BAccessTokenAdmin.getOne(admin, { id: obj.id })
            await expectDefinedSessionWith(fullToken.token, serviceUserClient.user.id, [organization.id])

            const [anotherOrganization] = await createTestOrganization(admin)
            await updateTestB2BAccessToken(admin, obj.id, { organization: { connect: { id: anotherOrganization.id } } })
            await expectDefinedSessionWith(fullToken.token, serviceUserClient.user.id, [anotherOrganization.id])
        })
    })
})
