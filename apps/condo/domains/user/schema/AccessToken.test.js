/**
 * Generated by `createschema user.AccessToken 'token:Uuid'`
 */

const { faker } = require('@faker-js/faker')
const { v4: uuidv4 } = require('uuid')

const { getRedisClient } = require('@open-condo/keystone/redis')
const {
    makeLoggedInAdminClient, makeClient, UUID_RE, expectValuesOfCommonFields,
    expectToThrowAccessDeniedError, expectToThrowValidationFailureError, expectToThrowGQLError,
    expectToThrowAuthenticationErrorToObj, expectToThrowAuthenticationErrorToObjects,
    expectToThrowAccessDeniedErrorToObj,
} = require('@open-condo/keystone/test.utils')

const {
    makeClientWithIntegrationAccess,
    createTestBillingIntegrationAccessRight,
    createTestBillingIntegrationOrganizationContext,
    updateTestBillingIntegrationOrganizationContext, createTestBillingIntegration,
} = require('@condo/domains/billing/utils/testSchema')
const { CONTEXT_FINISHED_STATUS } = require('@condo/domains/miniapp/constants')
const { createTestOrganization } = require('@condo/domains/organization/utils/testSchema')
const { Organization } = require('@condo/domains/organization/utils/testSchema')
const { registerNewOrganization } = require('@condo/domains/organization/utils/testSchema/Organization')
const {
    makeClientWithNewRegisteredAndLoggedInUser, makeClientWithSupportUser, makeClientWithServiceUser,
} = require('@condo/domains/user/utils/testSchema')
const { AccessToken, AccessTokenAdmin, createTestAccessToken, updateTestAccessToken } = require('@condo/domains/user/utils/testSchema')

describe('AccessToken', () => {
    const redisClient = getRedisClient()
    let admin
    let serviceUserClient
    let organization
    let billingIntegration
    let billingContext
    beforeEach(async () => {
        admin = await makeLoggedInAdminClient()
        serviceUserClient = await makeClientWithIntegrationAccess()

        ;[organization] = await registerNewOrganization(admin)
        ;[billingContext] = await createTestBillingIntegrationOrganizationContext(admin, organization, serviceUserClient.integration)
        ;[billingContext] = await updateTestBillingIntegrationOrganizationContext(admin, billingContext.id, { status: CONTEXT_FINISHED_STATUS })
        billingIntegration = serviceUserClient.integration
    })

    async function expectDefinedSessionWith (token, userId, allowedOrganizations) {
        const session = JSON.parse(await redisClient.get(`sess:${token}`))
        expect(session).toBeDefined()
        expect(session).toHaveProperty('cookie')
        expect(session).toHaveProperty('keystoneListKey', 'User')
        expect(session).toHaveProperty('keystoneItemId', userId)
        expect(session).toHaveProperty('extra')
        expect(session.extra).toEqual({ allowedOrganizations })
    }

    describe('CRUD tests', () => {
        describe('create', () => {
            test('admin can', async () => {
                const [obj, attrs] = await createTestAccessToken(admin, serviceUserClient.user)
                expectValuesOfCommonFields(obj, attrs, admin)
            })

            test('support can', async () => {
                const support = await makeClientWithSupportUser()

                const [obj, attrs] = await createTestAccessToken(support, serviceUserClient.user)
                expect(obj.id).toMatch(UUID_RE)
                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.createdBy).toEqual(expect.objectContaining({ id: support.user.id }))
            })

            test('user can', async () => {
                const client = await makeClientWithNewRegisteredAndLoggedInUser()

                const [obj, attrs] = await createTestAccessToken(client, serviceUserClient.user)

                expect(obj.id).toMatch(UUID_RE)
                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.createdBy).toEqual(expect.objectContaining({ id: client.user.id }))
            })

            test('anonymous can\'t', async () => {
                const client = await makeClient()

                await expectToThrowAuthenticationErrorToObj(async () => {
                    await createTestAccessToken(client, serviceUserClient.user)
                })
            })
        })

        describe('update', () => {
            test('admin can', async () => {
                const [objCreated] = await createTestAccessToken(admin, serviceUserClient.user)

                const [obj, attrs] = await updateTestAccessToken(admin, objCreated.id)

                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: admin.user.id }))
            })

            test('support can', async () => {
                const [objCreated] = await createTestAccessToken(admin, serviceUserClient.user)

                const client = await makeClientWithSupportUser()
                const [obj, attrs] = await updateTestAccessToken(client, objCreated.id)  // TODO(codegen): write 'support: update AccessToken' test

                expect(obj.id).toMatch(UUID_RE)
                expect(obj.dv).toEqual(1)
                expect(obj.sender).toEqual(attrs.sender)
                expect(obj.v).toEqual(2)
                expect(obj.updatedBy).toEqual(expect.objectContaining({ id: client.user.id }))
            })

            test('user can\'t', async () => {
                const [objCreated] = await createTestAccessToken(admin, serviceUserClient.user)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await updateTestAccessToken(client, objCreated.id)
                })
            })

            test('anonymous can\'t', async () => {
                const [objCreated] = await createTestAccessToken(admin, serviceUserClient.user)

                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObj(async () => {
                    await updateTestAccessToken(client, objCreated.id)
                })
            })
        })

        describe('hard delete', () => {
            test('admin can\'t', async () => {
                const [objCreated] = await createTestAccessToken(admin, serviceUserClient.user)

                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await AccessToken.delete(admin, objCreated.id)
                })
            })

            test('user can\'t', async () => {
                const [objCreated] = await createTestAccessToken(admin, serviceUserClient.user)

                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await AccessToken.delete(client, objCreated.id)
                })
            })

            test('anonymous can\'t', async () => {
                const [objCreated] = await createTestAccessToken(admin, serviceUserClient.user)

                const client = await makeClient()
                await expectToThrowAccessDeniedErrorToObj(async () => {
                    await AccessToken.delete(client, objCreated.id)
                })
            })
        })

        describe('read', () => {
            test('admin can', async () => {
                const [obj] = await createTestAccessToken(admin, serviceUserClient.user)

                const objs = await AccessToken.getAll(admin, {}, { sortBy: ['updatedAt_DESC'] })

                expect(objs.length).toBeGreaterThanOrEqual(1)
                expect(objs).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: obj.id,
                    }),
                ]))
            })

            test('user can only created by him', async () => {
                const client = await makeClientWithNewRegisteredAndLoggedInUser()
                const [ownToken] = await createTestAccessToken(client, serviceUserClient.user)
                const [anotherToken] = await createTestAccessToken(admin, serviceUserClient.user)

                const foundOwnToken = await AccessToken.getOne(client, { id: ownToken.id })
                expect(foundOwnToken).toBeDefined()
                expect(foundOwnToken.user).toEqual(expect.objectContaining({ id: serviceUserClient.user.id }))

                const foundAnotherToken = await AccessToken.getOne(client, { id: anotherToken.id })
                expect(foundAnotherToken).not.toBeDefined()
            })

            test('anonymous can\'t', async () => {
                await createTestAccessToken(admin, serviceUserClient.user)
                const client = await makeClient()
                await expectToThrowAuthenticationErrorToObjects(async () => {
                    await AccessToken.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })  // TODO(codegen): write 'anonymous: read AccessToken' test
                })
            })
        })
    })

    describe('Validation tests', () => {
        test('Should have correct dv field (=== 1)', async () => {
            const [token] = await createTestAccessToken(admin, serviceUserClient.user)
            expect(token).toHaveProperty('dv', 1)
        })
    })
    
    describe('Validations', () => {
        describe('Fields', () => {
            describe('token', () => {
                describe('read', () => {
                    test('admin can ', async () => {
                        const [token] = await createTestAccessToken(admin, serviceUserClient.user)
                        const foundToken = await AccessTokenAdmin.getOne(admin, { id: token.id } )
                        expect(foundToken.token).toMatch(UUID_RE)
                    })

                    test('support can\'t', async () => {
                        const support = await makeClientWithSupportUser()
                        const [token] = await createTestAccessToken(support, serviceUserClient.user)
                        await expectToThrowAccessDeniedError(async () => {
                            await AccessTokenAdmin.getOne(support, { id: token.id })
                        }, ['objs', 0, 'token'])
                    })

                    test('user can\'t', async () => {
                        const client = await makeClientWithNewRegisteredAndLoggedInUser()
                        const [token] = await createTestAccessToken(client, serviceUserClient.user)
                        await expectToThrowAccessDeniedError(async () => {
                            await AccessTokenAdmin.getOne(client, { id: token.id })
                        }, ['objs', 0, 'token'])
                    })

                    test('anonymous can\'t', async () => {
                        await createTestAccessToken(admin, serviceUserClient.user)
                        const client = await makeClient()
                        await expectToThrowAuthenticationErrorToObjects(async () => {
                            await AccessTokenAdmin.getAll(client, {}, { sortBy: ['updatedAt_DESC'] })  // TODO(codegen): write 'anonymous: read AccessToken' test
                        })
                    })
                })
                
                describe('create', () => {
                    test('defaults to random uuid', async () => {
                        const [obj] = await createTestAccessToken(admin, serviceUserClient.user)
                        const token = await AccessTokenAdmin.getOne(admin, { id: obj.id })
                        expect(token.token).toMatch(UUID_RE)
                    })
                    
                    test('can be set to uuid explicitly', async () => {
                        const uuid = uuidv4()
                        const [obj] = await createTestAccessToken(admin, serviceUserClient.user, { token: uuid })
                        const token = await AccessTokenAdmin.getOne(admin, { id: obj.id })
                        expect(token.token).toEqual(uuid)
                    })
                })
            })
        
            describe('signedToken', () => {
                test('depends on token value', async () => {
                    let [obj] = await createTestAccessToken(admin, serviceUserClient.user)
                    const token = await AccessTokenAdmin.getOne(admin, { id: obj.id })
                    expect(token.token).toMatch(UUID_RE)

                    await updateTestAccessToken(admin, obj.id, { token: uuidv4() })
                    const updatedToken = await AccessTokenAdmin.getOne(admin, { id: obj.id })
                    expect(token.token).not.toEqual(updatedToken.token)
                    expect(token.signedToken).not.toEqual(updatedToken.signedToken)
                })
            })

            describe('user', () => {
                test('should be service user', async () => {
                    const client = await makeClientWithNewRegisteredAndLoggedInUser()
                    await expectToThrowValidationFailureError(async () => {
                        await createTestAccessToken(admin, client.user)
                    }, '[user] No user specified or it has non-service type')
                })
            })

            describe('allowedOrganizations', () => {
                test('can be undefined', async () => {
                    const client = await makeClientWithNewRegisteredAndLoggedInUser()
                    const [obj] = await createTestAccessToken(client, serviceUserClient.user, { allowedOrganizations: undefined })
                    expect(obj).toHaveProperty('allowedOrganizations', null)
                })

                describe('should be array of uuids', () => {
                    const invalidCases = [
                        'asd',
                        123,
                        {},
                        [1, 2, 3],
                        [new Date(), {}, 'asd'],
                        ['a', 's', 'd'],
                    ]

                    const validCases = [
                        [],
                        [uuidv4()],
                        [uuidv4(), uuidv4()],
                    ]

                    test.each(invalidCases.map(arr => [arr]))('should throw validation error on %p', async (invalidAllowedOrganizations) => {
                        const client = await makeClientWithNewRegisteredAndLoggedInUser()
                        await expectToThrowGQLError(async () => {
                            await createTestAccessToken(client, serviceUserClient.user, { allowedOrganizations: invalidAllowedOrganizations })
                        }, {
                            message: '"allowedOrganizations" field validation error. JSON was not in the correct format',
                            code: 'BAD_USER_INPUT',
                            type: 'WRONG_FORMAT',
                        })
                    })

                    test.each(validCases.map(arr => [arr]))('shouldn\'t throw error on %p', async (validAllowedOrganizations) => {
                        if (!Array.isArray(validAllowedOrganizations)) validAllowedOrganizations = [validAllowedOrganizations]
                        const client = await makeClientWithNewRegisteredAndLoggedInUser()
                        const [obj] = await createTestAccessToken(client, serviceUserClient.user, { allowedOrganizations: validAllowedOrganizations })
                        expect(obj).toHaveProperty('allowedOrganizations')
                        expect(obj.allowedOrganizations).toEqual(validAllowedOrganizations)
                    })
                })
            })
        })
    })

    describe('Real life cases', () => {
        test('signed token allows to send requests with connected user accesses', async () => {
            const anonymous = await makeClient()
            const [obj] = await createTestAccessToken(admin, serviceUserClient.user)
            anonymous.setHeaders({ 'Authorization': `Bearer ${obj.signedToken}` })
            const [organizations] = await Organization.getAll(anonymous, {})
            expect(organizations).toBeDefined()
        })

        describe('signed token scopes accesses by allowed organizations', () => {
            
            test('organizations', async () => {
                const organizationsGenerationCount = 10
                const [integration] = await createTestBillingIntegration(admin)
                const serviceUserClient = await makeClientWithServiceUser()
                await createTestBillingIntegrationAccessRight(admin, integration, serviceUserClient.user)
                for (let i = 0; i < organizationsGenerationCount; i++) {
                    const [organization] = await createTestOrganization(admin)
                    let [context] = await createTestBillingIntegrationOrganizationContext(admin, organization, integration)
                ;[context] = await updateTestBillingIntegrationOrganizationContext(admin, context.id, { status: CONTEXT_FINISHED_STATUS })
                }

                const organizationsByService = await Organization.getAll(serviceUserClient, {})
                expect(organizationsByService.length).toBeGreaterThanOrEqual(organizationsGenerationCount)

                const allowedOrganizations = [organizationsByService[0].id]
                const [obj] = await createTestAccessToken(admin, serviceUserClient.user, { allowedOrganizations })
                const anonymous = await makeClient()
                anonymous.setHeaders({ 'Authorization': `Bearer ${obj.signedToken}` })
                const organizationsByToken = await Organization.getAll(anonymous, {})
                expect(organizationsByToken).toHaveLength(1)
                expect(organizationsByToken[0]).toHaveProperty('id', allowedOrganizations[0])
            })
        })
    })
    
    describe('Hooks', () => {
        test('sets session in redis after it\'s creation', async () => {
            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            const allowedOrganizations = [uuidv4()]
            const [obj] = await createTestAccessToken(client, serviceUserClient.user, { allowedOrganizations })
            const fullToken = await AccessTokenAdmin.getOne(admin, { id: obj.id })
            await expectDefinedSessionWith(fullToken.token, serviceUserClient.user.id, allowedOrganizations)
        })

        test('on soft delete removes previous session', async () => {
            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            const allowedOrganizations = [uuidv4()]
            const [obj] = await createTestAccessToken(client, serviceUserClient.user, { allowedOrganizations })
            const fullToken = await AccessTokenAdmin.getOne(admin, { id: obj.id })
            let session = await redisClient.get(`sess:${fullToken.token}`)
            await expectDefinedSessionWith(fullToken.token, serviceUserClient.user.id, allowedOrganizations)

            await updateTestAccessToken(admin, obj.id, { deletedAt: new Date().toISOString() })
            session = await redisClient.get(`sess:${fullToken.token}`)
            expect(session).toBeNull()
        })

        test('on token field update removes previous session and adds new one', async () => {
            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            const allowedOrganizations = [uuidv4()]
            const [obj] = await createTestAccessToken(client, serviceUserClient.user, { allowedOrganizations })
            const fullToken = await AccessTokenAdmin.getOne(admin, { id: obj.id })
            await expectDefinedSessionWith(fullToken.token, serviceUserClient.user.id, allowedOrganizations)

            const newToken = uuidv4()
            await updateTestAccessToken(admin, obj.id, { token: newToken })
            const session = await redisClient.get(`sess:${fullToken.token}`)
            expect(session).toBeNull()
            await expectDefinedSessionWith(newToken, serviceUserClient.user.id, allowedOrganizations)
        })

        test('updates session value on allowedOrganizations field change', async () => {
            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            const allowedOrganizations = [uuidv4()]
            const [obj] = await createTestAccessToken(client, serviceUserClient.user, { allowedOrganizations })
            const fullToken = await AccessTokenAdmin.getOne(admin, { id: obj.id })
            await expectDefinedSessionWith(fullToken.token, serviceUserClient.user.id, allowedOrganizations)

            const newAllowedOrganizations = [uuidv4()]
            await updateTestAccessToken(admin, obj.id, { allowedOrganizations: newAllowedOrganizations })
            await expectDefinedSessionWith(fullToken.token, serviceUserClient.user.id, newAllowedOrganizations)
        })
    })
})
