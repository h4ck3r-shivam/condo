/**
 * Generated by `createschema user.AccessToken 'token:Uuid'`
 */

const Ajv = require('ajv')
const addFormats = require('ajv-formats')
const cookieSignature = require('cookie-signature')
const get = require('lodash/get')
const { v4: uuid } = require('uuid')

const conf = require('@open-condo/config')
const { userIsAdmin } = require('@open-condo/keystone/access')
const { historical, versioned, uuided, tracked, softDeleted, dvAndSender } = require('@open-condo/keystone/plugins')
const { GQLListSchema } = require('@open-condo/keystone/schema')

const { WRONG_FORMAT } = require('@condo/domains/common/constants/errors')
const { getGQLErrorValidator } = require('@condo/domains/common/schema/json.utils')
const { SERVICE_USER_FIELD } = require('@condo/domains/miniapp/schema/fields/accessRight')
const access = require('@condo/domains/user/access/AccessToken')


const ajv = new Ajv()
addFormats(ajv)


const allowedOrganizationsIdsJsonValidator = getGQLErrorValidator(ajv.compile({
    type: 'array',
    items: {
        type: 'string',
        format: 'uuid',
    },
}), WRONG_FORMAT)

function makeCookie () {
    return {
        originalMaxAge: 2147483647000,
        expires: '2092-11-04T12:43:45.563Z',
        secure: false,
        httpOnly: true,
        path: '/',
        sameSite: 'Lax',
    }
}

function setSession (sessionStore, item, data) {
    const userId = get(item, 'user.id', item.user)
    sessionStore.set(item.token, {
        cookie: makeCookie(),
        keystoneListKey: 'User',
        keystoneItemId: userId,
        extra: data,
    })
}

function destroySession (sessionStore, item) {
    sessionStore.destroy(item.token)
}

const AccessToken = new GQLListSchema('AccessToken', {
    schemaDoc: 'Permanent access tokens for users to constraint scope',
    fields: {

        token: {
            schemaDoc: 'Actual token',
            type: 'Uuid',
            defaultValue: () => uuid(),
            isRequired: true,
            access: {
                read: userIsAdmin,
                create: userIsAdmin,
                update: userIsAdmin,
            },
        },

        signedToken: {
            schemaDoc: 'Pass this in header Authorization: \'Bearer <signedToken>\'',
            type: 'Virtual',
            graphQLReturnType: 'String',
            resolver: (item) => {
                return cookieSignature.sign(item.token, conf.COOKIE_SECRET)
            },
        },

        user: {
            ...SERVICE_USER_FIELD,
        },

        allowedOrganizations: {
            schemaDoc: 'List of organizations ids, which service user is allowed to use',
            type: 'Json',
            isRequired: false,
            hooks: {
                validateInput: allowedOrganizationsIdsJsonValidator,
            },
        },

    },
    hooks: {
        afterChange: ({ context, operation, existingItem, updatedItem }) => {
            const tokenUpdated = operation === 'update' && (updatedItem['token'] !== existingItem['token'])
            const softDeleted = operation === 'update' && !existingItem['deletedAt'] && updatedItem['deletedAt']

            if (tokenUpdated || softDeleted) {
                destroySession(context.req.sessionStore, existingItem)
            }

            if (!softDeleted) {
                setSession(context.req.sessionStore, updatedItem, {
                    allowedOrganizations: updatedItem['allowedOrganizations'],
                })
            }
        },
    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    access: {
        read: access.canReadAccessTokens,
        create: access.canManageAccessTokens,
        update: access.canManageAccessTokens,
        delete: false,
        auth: true,
    },
})

module.exports = {
    AccessToken: AccessToken,
}
