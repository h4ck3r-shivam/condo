/**
 * Generated by `createschema webhook.WebHookSubscription 'webhook:Relationship:WebHook:CASCADE; model:Text;'`
 */
const dayjs = require('dayjs')
const { isEmpty, fromPairs, toPairs } = require('lodash')

const { Text, Relationship, Integer, Select, Checkbox, DateTimeUtc, CalendarDay, Decimal, Password, File, Url } = require('@keystonejs/fields')
const { GQLListSchema, getSchemaNames } = require('@condo/keystone/schema')
const { historical, versioned, uuided, tracked, softDeleted } = require('@condo/keystone/plugins')

const { dvAndSender } = require('@condo/domains/common/schema/plugins/dvAndSender')
const access = require('@condo/domains/webhook/access/WebHookSubscription')

const { REGISTERED_WEBHOOK_MODELS } = require('../constants')
const { normalizeModelFieldsObject } = require('../utils/buildWebHookGQLQuery.utils')

const WebHookSubscription = new GQLListSchema('WebHookSubscription', {
    schemaDoc: 'Determines which models the WebHook will be subscribed to. We need to define a list of models, when changing which the webhook will be called.',
    fields: {
        webhook: {
            schemaDoc: 'WebHook',
            type: Relationship,
            ref: 'WebHook',
            isRequired: true,
            knexOptions: { isNotNullable: true },
            kmigratorOptions: { null: false, on_delete: 'models.CASCADE' },
        },

        lastUpdatedAt: {
            schemaDoc: 'When was the date of the last successful synchronization. If there is a change, we only send the data updated after that date',
            type: DateTimeUtc,
            isRequired: true,
            defaultValue: dayjs('2020-01-01').toISOString(),
        },
        lastUpdatedAtOffset: {
            schemaDoc: 'When we have a lot of changes with the same updatedAt date we need to skip some changes which we already sent',
            type: Integer,
            isRequired: true,
            defaultValue: 0,
        },

        model: {
            schemaDoc: 'Model name which subscribed to',
            type: Select,
            isRequired: true,
            dataType: 'string',
            options: REGISTERED_WEBHOOK_MODELS,
        },
        fields: {
            schemaDoc: 'List of model fields in JSON format',
            type: 'Json',
            isRequired: true,
            defaultValue: { id: true, updatedAt: true },
            kmigratorOptions: { null: false },
            hooks: {
                resolveInput: ({ resolvedData }) => {
                    return normalizeModelFieldsObject(resolvedData['fields'])
                },
            },
        },
        filters: {
            schemaDoc: 'List of model query filters for webhook data',
            type: 'Json',
            isRequired: true,
            defaultValue: {},
            kmigratorOptions: { null: false },
        },

    },
    plugins: [uuided(), versioned(), tracked(), softDeleted(), dvAndSender(), historical()],
    hooks: {
        validateInput: ({ resolvedData, existingItem, addValidationError, context }) => {
            const model = resolvedData['model'] || existingItem['model']
            const schemas = getSchemaNames()
            if (!schemas.includes(model)) return addValidationError('not registered schema name')
            // TODO(pahaz): validate filters and fields
        },
    },
    access: {
        read: access.canReadWebHookSubscriptions,
        create: access.canManageWebHookSubscriptions,
        update: access.canManageWebHookSubscriptions,
        delete: false,
        auth: true,
    },
})


module.exports = {
    WebHookSubscription,
}
