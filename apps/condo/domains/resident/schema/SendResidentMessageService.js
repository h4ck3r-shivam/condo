/**
 * Generated by `createservice resident.SendResidentMessageService --type mutations`
 */
const { isEmpty } = require('lodash')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema } = require('@open-condo/keystone/schema')

const { BillingCategory } = require('@condo/domains/billing/utils/serverSchema')
const { NOT_FOUND } = require('@condo/domains/common/constants/errors')
const { MESSAGE_META } = require('@condo/domains/notification/constants/constants')
const { Organization } = require('@condo/domains/organization/utils/serverSchema')
const access = require('@condo/domains/resident/access/SendResidentMessageService')
const { sendResidentMessageTask } = require('@condo/domains/resident/tasks/sendResidentMessage.task')

const SUCCESS_STATUS = 'Ok'

/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    INVALID_CATEGORY_PROVIDED: {
        mutation: 'sendResidentMessage',
        variable: ['data', 'data', 'category'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Please use one of allowed category values',
        messageForUser: 'api.resident.sendResidentMessage.INVALID_CATEGORY_PROVIDED',
    },
    INVALID_ORGANIZATION_PROVIDED: {
        mutation: 'sendResidentMessage',
        variable: ['data', 'organizationId'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Please provide existing non-deleted organization id',
        messageForUser: 'api.resident.sendResidentMessage.INVALID_ORGANIZATION_PROVIDED',
    },
    PROPERTY_IS_REQUIRED: {
        mutation: 'sendResidentMessage',
        variable: ['data', 'propertyDetails'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Please provide either property or billingProperty id for each details item',
        messageForUser: 'api.resident.sendResidentMessage.PROPERTY_IS_REQUIRED',
    },
    PROPERTY_DETAILS_IS_EMPTY: {
        mutation: 'sendResidentMessage',
        variable: ['data', 'propertyDetails'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Property details could not be empty',
        messageForUser: 'api.resident.sendResidentMessage.PROPERTY_DETAILS_IS_EMPTY',
    },
    INVALID_NOTIFICATION_TYPE_PROVIDED: {
        mutation: 'sendResidentMessage',
        variable: ['data', 'type'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Please use one of allowed notification types',
        messageForUser: 'api.resident.sendResidentMessage.INVALID_NOTIFICATION_TYPE_PROVIDED',
    },
}

/**
 * Validate notification data for SendResidentMessageService. Throws typed errors on invalid values.
 * @param context
 * @param data
 * @returns {Promise<boolean>}
 */
const validateResidentMessageData = async (context, data) => {
    const { organizationId, propertyDetails, type, data: notificationData = {} } = data
    const { categoryId } = notificationData

    // Validate notification type
    if (!MESSAGE_META[type]) throw new GQLError(ERRORS.INVALID_NOTIFICATION_TYPE_PROVIDED, context)

    if (isEmpty(propertyDetails)) throw new GQLError(ERRORS.PROPERTY_DETAILS_IS_EMPTY, context)

    // Validate property/billingProperty existance for each details item
    for (const detail of propertyDetails) {
        if (!detail.propertyId && !detail.billingPropertyId) throw new GQLError(ERRORS.PROPERTY_IS_REQUIRED, context)
    }

    // validate organization id
    const organizationData = await Organization.getOne(context, { id: organizationId, deletedAt: null })

    if (isEmpty(organizationData)) throw new GQLError(ERRORS.INVALID_ORGANIZATION_PROVIDED, context)

    if (!isEmpty(categoryId)) {
        // validate billing category id
        const categoryData = await BillingCategory.getAll(context, { id: categoryId, deletedAt: null })

        if (isEmpty(categoryData)) throw new GQLError(ERRORS.INVALID_CATEGORY_PROVIDED, context)
    }

    return true
}

const SendResidentMessageService = new GQLCustomSchema('SendResidentMessageService', {
    types: [
        {
            access: true,
            type: 'input PropertyUnitInput { unitType: String, unitName: String }',
        },
        {
            access: true,
            type: 'input PropertyDetailsInput { propertyId: ID, billingPropertyId: ID, sections: [Int], units: [PropertyUnitInput], phones: [String], billingAccounts: [ID] }',
        },
        {
            access: true,
            type: 'input SendResidentMessageDataInput { title: String, message: String, urlTemplate: String, categoryId: String, period: String }',
        },
        {
            access: true,
            type: 'input SendResidentMessageInput { dv: Int!, sender: JSON!, organizationId: ID!, propertyDetails: [PropertyDetailsInput]!, uniqKeyTemplate: String, type: String!, data: SendResidentMessageDataInput }',
        },
        {
            access: true,
            type: 'type SendResidentMessageOutput { status: String! }',
        },
    ],
    
    mutations: [
        {
            access: access.canSendResidentMessage,
            schema: 'sendResidentMessage(data: SendResidentMessageInput!): SendResidentMessageOutput',
            doc: {
                summary: 'Sends notification to all residents of organization properties',
                errors: ERRORS,
            },
            resolver: async (parent, args, context) => {
                const { data } = args

                await validateResidentMessageData(context, data)
                await sendResidentMessageTask.delay(JSON.stringify(data))

                return { status: SUCCESS_STATUS }
            },
        },
    ],
    
})

module.exports = {
    ERRORS,
    SUCCESS_STATUS,
    SendResidentMessageService,
    validateResidentMessageData,
}
