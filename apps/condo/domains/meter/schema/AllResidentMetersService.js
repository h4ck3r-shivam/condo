/**
 * Generated by `createservice meter.AllResidentMetersService`
 */

const { GQLError, GQLErrorCode: { BAD_USER_INPUT, INTERNAL_ERROR } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema, find } = require('@open-condo/keystone/schema')

const { NOT_FOUND } = require('@condo/domains/common/constants/errors')
const access = require('@condo/domains/meter/access/AllResidentMetersService')
const { MeterResource } = require('@condo/domains/meter/utils/serverSchema')

/**
 * List of possible errors, that this custom schema can throw
 * They will be rendered in documentation section in GraphiQL for this custom schema
 */
const ERRORS = {
    NAME_OF_ERROR_FOR_USAGE_INSIDE_THIS_MODULE_ONLY: { mutation: 'allResidentMeters',
        variable: ['data', 'someVar'], // TODO(codegen): Provide path to a query/mutation variable, whose value caused this error. Remove this property, if variables are not relevant to this error
        code: BAD_USER_INPUT, // TODO(codegen): use one of the basic codes, declared in '@open-condo/keystone/errors'
        type: NOT_FOUND, // TODO(codegen): use value from `constants/errors.js` either from 'common' or current domain
        message: 'Describe what happened for developer',
        messageForUser: 'api.user.allResidentMeters.NAME_OF_ERROR_FOR_USAGE_INSIDE_THIS_MODULE_ONLY', // TODO(codegen): localized message for user, use translation files
    },
}

const AllResidentMetersService = new GQLCustomSchema('AllResidentMetersService', {
    types: [
        {
            access: true,
            type: 'input AllResidentMetersInput { dv: Int!, sender: SenderFieldInput!, resident: ID!, first: Int, skip: Int }',
        },
        {
            access: true,
            type: 'type AllResidentMetersOutput { meters: [Meter!] }',
        },
    ],

    queries: [
        {
            access: access.canAllResidentMeters,
            schema: 'allResidentMeters(data: AllResidentMetersInput!): AllResidentMetersOutput',
            resolver: async (parent, args, context, info, extra = {}) => {
                // TODO(codegen): write AllResidentMetersService logic!
                const { data: { resident: residentId, first, skip } } = args

                const meters = []

                const [resident] = await find('Resident', {
                    id: residentId,
                    organization: { deletedAt: null },
                    property: { deletedAt: null },
                    deletedAt: null,
                })

                if (resident) {
                    const condition = { deletedAt: null }
                    if (resident.addressKey) {
                        condition['addressKey'] = resident.addressKey
                    } else {
                        condition['address_i'] = resident.address
                    }
                    const meterResourceOwners = await find('MeterResourceOwner', condition)
                    const meterResources = await MeterResource.getAll(context, {})

                    const meterWhere = {
                        unitName: resident.unitName,
                        unitType: resident.unitType,
                        deletedAt: null,
                    }

                    for (const meterResourceOwner of meterResourceOwners) {
                        const foundMeters = await find('Meter', {
                            organization: { id: meterResourceOwner.organization },
                            resource: { id: meterResourceOwner.resource },
                            ...meterWhere,
                        })

                        if (foundMeters && foundMeters.length > 0) {
                            meters.push(...foundMeters)
                            meterResources.splice(meterResources.findIndex(resource => resource.id === foundMeters[0].resource), 1)
                        }
                    }

                    if (meterResources.length > 0) {
                        for (const meterResource of meterResources) {
                            const foundMeters = await find('Meter', {
                                organization: { id: resident.organization },
                                resource: { id: meterResource.id },
                                ...meterWhere,
                            })

                            if (foundMeters) {
                                meters.push(...foundMeters)
                            }
                        }
                    }
                }

                // const meterResourceOwners = await find('MeterResourceOwner', {
                //
                // })


                // TODO: throw ERRORS in a following way
                // throw new GQLError(ERRORS.NAME_OF_ERROR_FOR_USAGE_INSIDE_THIS_MODULE_ONLY)
                return { meters }
            },
        },
    ],
})

module.exports = {
    AllResidentMetersService,
}
