/**
 * Generated by `createservice meter.AllResidentMetersService`
 */

const { GQLError, GQLErrorCode: { BAD_USER_INPUT, INTERNAL_ERROR } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema, find } = require('@open-condo/keystone/schema')

const { NOT_FOUND } = require('@condo/domains/common/constants/errors')
const access = require('@condo/domains/meter/access/AllResidentMetersService')
const { MeterResource } = require('@condo/domains/meter/utils/serverSchema')

const ERRORS = {
    RESIDENT_DOES_NOT_EXISTS: {
        query: 'allResidentMeters',
        variable: ['data', 'resident'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Resident with provided id does not exist',
    },
}

const AllResidentMetersService = new GQLCustomSchema('AllResidentMetersService', {
    types: [
        {
            access: true,
            type: 'input AllResidentMetersInput { dv: Int!, sender: SenderFieldInput!, resident: ID!, first: Int, skip: Int }',
        },
        {
            access: true,
            type: 'type AllResidentMetersOutput { meters: [Meter!] }',
        },
    ],

    queries: [
        {
            access: access.canAllResidentMeters,
            schema: 'allResidentMeters(data: AllResidentMetersInput!): AllResidentMetersOutput',
            resolver: async (parent, args, context, info, extra = {}) => {
                const { data: { resident: residentId, first, skip } } = args

                const [resident] = await find('Resident', {
                    id: residentId,
                    organization: { deletedAt: null },
                    property: { deletedAt: null },
                    deletedAt: null,
                    user: { id: context.authedItem.id },
                })

                if (resident) {
                    const meters = []

                    const condition = {
                        deletedAt: null,
                        OR: [
                            { addressKey: resident.addressKey },
                            { address_i: resident.address },
                        ],
                    }

                    const userConsumers = await find('ServiceConsumer', {
                        resident: { id: residentId, deletedAt: null },
                        organization: { deletedAt: null },
                        deletedAt: null,
                    })

                    const accountNumberWhere = {
                        OR: userConsumers.map(serviceConsumer => ({ AND: [{ accountNumber: serviceConsumer.accountNumber }] })),
                    }

                    const meterResourceOwners = await find('MeterResourceOwner', condition)
                    const meterResources = await MeterResource.getAll(context, {})

                    const meterWhere = {
                        unitName: resident.unitName,
                        unitType: resident.unitType,
                        deletedAt: null,
                        ...accountNumberWhere,
                    }

                    for (const meterResourceOwner of meterResourceOwners) {
                        const foundMeters = await find('Meter', {
                            organization: { id: meterResourceOwner.organization },
                            resource: { id: meterResourceOwner.resource },
                            ...meterWhere,
                        })

                        if (foundMeters && foundMeters.length > 0) {
                            meters.push(...foundMeters)
                            meterResources.splice(meterResources.findIndex(resource => resource.id === foundMeters[0].resource), 1)
                        }
                    }

                    if (meterResources.length > 0) {
                        for (const meterResource of meterResources) {
                            const foundMeters = await find('Meter', {
                                organization: { id: resident.organization },
                                resource: { id: meterResource.id },
                                ...meterWhere,
                            })

                            if (foundMeters) {
                                meters.push(...foundMeters)
                            }
                        }
                    }

                    return { meters }
                }

                throw new GQLError(ERRORS.RESIDENT_DOES_NOT_EXISTS, context)
            },
        },
    ],
})

module.exports = {
    AllResidentMetersService,
}
