/**
 * Generated by `createservice meter.AllResidentMetersService`
 */

const { take, drop } = require('lodash')

const { GQLError, GQLErrorCode: { BAD_USER_INPUT } } = require('@open-condo/keystone/errors')
const { GQLCustomSchema, find } = require('@open-condo/keystone/schema')

const { NOT_FOUND } = require('@condo/domains/common/constants/errors')
const access = require('@condo/domains/meter/access/AllResidentMetersService')
const {
    Meter,
    MeterResourceOwner,
    MeterResource,
} = require('@condo/domains/meter/utils/serverSchema')
const { Resident } = require('@condo/domains/resident/utils/serverSchema')

const ERRORS = {
    RESIDENT_DOES_NOT_EXISTS: {
        query: 'allResidentMeters',
        variable: ['data', 'resident'],
        code: BAD_USER_INPUT,
        type: NOT_FOUND,
        message: 'Resident with provided id does not exist',
    },
}

const AllResidentMetersService = new GQLCustomSchema('AllResidentMetersService', {
    types: [
        {
            access: true,
            type: 'input AllResidentMetersInput { where: ResidentWhereUniqueInput!, first: Int, skip: Int }',
        },
        {
            access: true,
            type: 'type ResidentMeter { organization: Organization!, property: Property!, resource: MeterResource!, numberOfTariffs: Int, installationDate: String, commissioningDate: String, verificationDate: String, nextVerificationDate: String, controlReadingsDate: String, sealingDate: String, isAutomatic: Boolean!, number: String!, accountNumber: String!, unitName: String!, unitType: String!, place: String, meta: JSON, b2bApp: B2BApp, b2cApp: B2CApp, v: Int, dv: Int!, sender: SenderField!, id: ID!, createdBy: User, updatedBy: User, deletedAt: String, updatedAt: String, createdAt: String, newId: String }',
        },
    ],

    queries: [
        {
            access: access.canAllResidentMeters,
            schema: 'allResidentMeters(where: ResidentWhereUniqueInput!, first: Int, skip: Int): [ResidentMeter!]',
            resolver: async (parent, args, context, info, extra = {}) => {

                const { where: { id: residentId }, first, skip } = args

                const residentWhere = {
                    id: residentId,
                    organization: { deletedAt: null },
                    property: { deletedAt: null },
                    deletedAt: null,
                    user: { id: context.authedItem.id },
                }

                if (context.authedItem.isAdmin || context.authedItem.isSupport) {
                    delete residentWhere['user']
                }

                const resident = await Resident.getOne(context, residentWhere)

                if (!resident) throw new GQLError(ERRORS.RESIDENT_DOES_NOT_EXISTS, context)

                const meters = []

                const condition = {
                    deletedAt: null,
                    OR: [
                        { addressKey: resident.addressKey },
                        { address_i: resident.address },
                    ],
                }

                const userConsumers = await find('ServiceConsumer', {
                    resident: { id: residentId, deletedAt: null },
                    organization: { deletedAt: null },
                    deletedAt: null,
                })

                const accountNumberWhere = {
                    OR: userConsumers.map(serviceConsumer => ({ AND: [{ accountNumber: serviceConsumer.accountNumber }] })),
                }

                const meterResourceOwners = await MeterResourceOwner.getAll(context, condition)
                const meterResources = await MeterResource.getAll(context, {})

                const meterWhere = {
                    unitName: resident.unitName,
                    unitType: resident.unitType,
                    deletedAt: null,
                    ...accountNumberWhere,
                }

                for (const meterResourceOwner of meterResourceOwners) {
                    const foundMeters = await Meter.getAll(context, {
                        organization: { id: meterResourceOwner.organization.id },
                        resource: { id: meterResourceOwner.resource.id },
                        ...meterWhere,
                    })

                    if (foundMeters && foundMeters.length > 0) {
                        meters.push(...foundMeters)
                        meterResources.splice(meterResources.findIndex(resource => resource.id === foundMeters[0].resource.id), 1)
                    }
                }

                if (meterResources.length > 0) {
                    for (const meterResource of meterResources) {
                        const foundMeters = await Meter.getAll(context, {
                            organization: { id: resident.organization.id },
                            resource: { id: meterResource.id },
                            ...meterWhere,
                        })

                        if (foundMeters) {
                            meters.push(...foundMeters)
                        }
                    }
                }

                return take(drop(meters, skip > 0 ? skip : 0), first > 0 ? first : meters.length)
            },
        },
    ],
})

module.exports = {
    AllResidentMetersService,
}
